<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FP-GPT</title>
    
    <!-- Tailwind CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        dark: {
                            100: '#0f1118',
                            200: '#161926',
                            300: '#1e2235',
                            400: '#2a2f44'
                        },
                        accent: {
                            blue: '#60a5fa',
                            green: '#34d399',
                            purple: '#8b5cf6'
                        }
                    },
                    animation: {
                        'gradient': 'gradient 8s linear infinite',
                        'pulse-slow': 'pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite'
                    },
                    keyframes: {
                        gradient: {
                            '0%, 100%': {
                                'background-size': '200% 200%',
                                'background-position': 'left center'
                            },
                            '50%': {
                                'background-size': '200% 200%',
                                'background-position': 'right center'
                            }
                        }
                    }
                }
            }
        }
    </script>
    
    <!-- Update Lucide Icons import -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.min.js"></script>

    <script>
        // Wikipedia Service Implementation
        class WikipediaService {
            static async search(query) {
                try {
                    const baseUrl = 'https://en.wikipedia.org/w/api.php';
                    const searchParams = new URLSearchParams({
                        action: 'query',
                        list: 'search',
                        srsearch: query,
                        format: 'json',
                        origin: '*',
                        srlimit: '3'
                    });

                    const response = await fetch(`${baseUrl}?${searchParams}`);
                    const data = await response.json();
                    
                    if (!data.query?.search?.length) return null;

                    const titles = data.query.search.map(result => result.title);
                    const contentParams = new URLSearchParams({
                        action: 'query',
                        prop: 'extracts',
                        exintro: '1',
                        explaintext: '1',
                        titles: titles.join('|'),
                        format: 'json',
                        origin: '*'
                    });

                    const contentResponse = await fetch(`${baseUrl}?${contentParams}`);
                    const contentData = await contentResponse.json();
                    const pages = Object.values(contentData.query.pages);

                    return pages
                        .filter(page => page.extract)
                        .map(page => `ðŸ“š ${page.title}\n\n${page.extract}`)
                        .join('\n\n---\n\n');
                } catch (error) {
                    console.error('Wikipedia search failed:', error);
                    return null;
                }
            }
        }

        // DuckDuckGo Service Implementation
        class DuckDuckGoService {
            static async search(query) {
                try {
                    const response = await fetch(`https://api.duckduckgo.com/?q=${encodeURIComponent(query)}&format=json`);
                    const data = await response.json();
                    
                    const results = [];
                    
                    if (data.Abstract) {
                        results.push(`ðŸ“ Summary:\n${data.Abstract}`);
                    }
                    
                    if (data.RelatedTopics?.length > 0) {
                        const topics = data.RelatedTopics
                            .slice(0, 3)
                            .map(topic => topic.Text)
                            .filter(Boolean)
                            .join('\nâ€¢ ');
                            
                        if (topics) {
                            results.push(`ðŸ” Related Information:\nâ€¢ ${topics}`);
                        }
                    }

                    return results.length > 0 ? results.join('\n\n') : null;
                } catch (error) {
                    console.error('DuckDuckGo search failed:', error);
                    return null;
                }
            }
        }

        // Reddit Service Implementation
        class RedditService {
            static async search(query) {
                try {
                    const response = await fetch(`https://www.reddit.com/search.json?q=${encodeURIComponent(query)}&limit=3`);
                    const data = await response.json();
                    
                    if (!data.data?.children?.length) return null;

                    return data.data.children
                        .map(post => {
                            const { title, selftext, subreddit, score, num_comments } = post.data;
                            return [
                                `ðŸ“Œ r/${subreddit}`,
                                `ðŸ“ ${title}`,
                                selftext ? selftext.substring(0, 300) + (selftext.length > 300 ? '...' : '') : '',
                                `ðŸ‘ ${score} | ðŸ’¬ ${num_comments}`
                            ].filter(Boolean).join('\n');
                        })
                        .join('\n\n---\n\n');
                } catch (error) {
                    console.error('Reddit search failed:', error);
                    return null;
                }
            }
        }

        // Wikidata Service Implementation
        class WikidataService {
            static async search(query) {
                try {
                    const params = new URLSearchParams({
                        action: 'wbsearchentities',
                        search: query,
                        language: 'en',
                        format: 'json',
                        origin: '*',
                        limit: '3'
                    });

                    const response = await fetch(`https://www.wikidata.org/w/api.php?${params}`);
                    const data = await response.json();

                    if (!data.search?.length) return null;

                    return data.search
                        .map(item => [
                            `ðŸ·ï¸ ${item.label}`,
                            `ðŸ“ ${item.description || 'No description available'}`,
                            item.aliases ? `ðŸ”„ Also known as: ${item.aliases.join(', ')}` : null
                        ].filter(Boolean).join('\n'))
                        .join('\n\n---\n\n');
                } catch (error) {
                    console.error('Wikidata search failed:', error);
                    return null;
                }
            }
        }

        // arXiv Service Implementation
        class ArXivService {
            static async search(query) {
                try {
                    const params = new URLSearchParams({
                        search_query: `all:${encodeURIComponent(query)}`,
                        start: '0',
                        max_results: '3'
                    });

                    const response = await fetch(`http://export.arxiv.org/api/query?${params}`);
                    const xmlText = await response.text();
                    
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
                    const entries = xmlDoc.getElementsByTagName('entry');

                    if (entries.length === 0) return null;

                    return Array.from(entries)
                        .map(entry => {
                            const title = entry.getElementsByTagName('title')[0]?.textContent || '';
                            const summary = entry.getElementsByTagName('summary')[0]?.textContent || '';
                            const authors = Array.from(entry.getElementsByTagName('author'))
                                .map(author => author.getElementsByTagName('name')[0]?.textContent || '')
                                .join(', ');
                            const published = entry.getElementsByTagName('published')[0]?.textContent || '';
                            
                            return [
                                `ðŸ“„ ${title.trim()}`,
                                `ðŸ‘¥ Authors: ${authors}`,
                                `ðŸ“… Published: ${new Date(published).toLocaleDateString()}`,
                                '',
                                summary.trim()
                            ].join('\n');
                        })
                        .join('\n\n---\n\n');
                } catch (error) {
                    console.error('arXiv search failed:', error);
                    return null;
                }
            }
        }

        // Unpaywall Service Implementation
        class UnpaywallService {
            static get EMAIL() { return 'dronpancholi@gmail.com'; }
            static get BASE_URL() { return 'https://api.unpaywall.org/v2'; }
            static get CACHE_DURATION() { return 24 * 60 * 60 * 1000; } // 24 hours
            static get MAX_RESULTS() { return 5; }
            
            static cache = new Map();

            static async search(query) {
                try {
                    // First search arXiv to get DOIs
                    const dois = await this.findDOIs(query);
                    if (!dois.length) return null;

                    // Check cache for each DOI
                    const cachedResults = this.getFromCache(dois);
                    const uncachedDois = dois.filter(doi => !cachedResults.has(doi));

                    // Fetch uncached papers
                    const newResults = await this.fetchPapers(uncachedDois);
                    
                    // Combine cached and new results
                    const allResults = new Map([...cachedResults, ...newResults]);
                    
                    // Format and return results
                    return this.formatResults(allResults);
                } catch (error) {
                    console.error('Unpaywall search failed:', error);
                    return null;
                }
            }

            static async findDOIs(query) {
                try {
                    // Use Crossref API to search for DOIs
                    const params = new URLSearchParams({
                        q: query,
                        rows: this.MAX_RESULTS.toString(),
                        select: 'DOI,title,author,published-print',
                        mailto: this.EMAIL
                    });

                    const response = await fetch(`https://api.crossref.org/works?${params}`);
                    const data = await response.json();

                    return data.message.items
                        .filter(item => item.DOI)
                        .map(item => item.DOI);
                } catch (error) {
                    console.error('DOI search failed:', error);
                    return [];
                }
            }

            static async fetchPapers(dois) {
                const results = new Map();

                // Fetch papers in parallel with rate limiting
                const papers = await Promise.all(
                    dois.map((doi, index) => 
                        new Promise(resolve => 
                            setTimeout(() => this.fetchPaper(doi).then(resolve), index * 100)
                        )
                    )
                );

                // Process results
                papers.forEach((paper, index) => {
                    if (paper) {
                        results.set(dois[index], paper);
                        this.addToCache(dois[index], paper);
                    }
                });

                return results;
            }

            static async fetchPaper(doi) {
                try {
                    const response = await fetch(
                        `${this.BASE_URL}/${encodeURIComponent(doi)}?email=${this.EMAIL}`
                    );
                    
                    if (!response.ok) return null;
                    
                    const data = await response.json();
                    
                    // Only return open access papers
                    if (!data.is_oa) return null;

                    return {
                        title: data.title,
                        authors: data.z_authors?.map(a => a.given + ' ' + a.family).join(', '),
                        journal: data.journal_name,
                        year: data.year,
                        doi: data.doi,
                        pdf_url: data.best_oa_location?.url_for_pdf,
                        abstract: data.abstract,
                        published_date: data.published_date
                    };
                } catch (error) {
                    console.error(`Failed to fetch paper ${doi}:`, error);
                    return null;
                }
            }

            static formatResults(papers) {
                if (!papers.size) return null;

                return Array.from(papers.values())
                    .filter(paper => paper && paper.title)
                    .map(paper => {
                        const parts = [
                            `ðŸ“‘ ${paper.title}`,
                            paper.authors ? `ðŸ‘¥ Authors: ${paper.authors}` : null,
                            paper.journal ? `ðŸ“° Journal: ${paper.journal}` : null,
                            paper.year ? `ðŸ“… Year: ${paper.year}` : null,
                            paper.doi ? `ðŸ” DOI: ${paper.doi}` : null,
                            paper.pdf_url ? `ðŸ“„ PDF: ${paper.pdf_url}` : null,
                            '',
                            paper.abstract ? paper.abstract.trim() : 'No abstract available'
                        ];

                        return parts.filter(Boolean).join('\n');
                    })
                    .join('\n\n---\n\n');
            }

            static getFromCache(dois) {
                const results = new Map();
                const now = Date.now();

                dois.forEach(doi => {
                    const cached = this.cache.get(doi);
                    if (cached && now - cached.timestamp < this.CACHE_DURATION) {
                        results.set(doi, cached.data);
                    }
                });

                return results;
            }

            static addToCache(doi, data) {
                this.cache.set(doi, {
                    data,
                    timestamp: Date.now()
                });

                // Clean old cache entries
                if (this.cache.size > 1000) {
                    const oldestKey = Array.from(this.cache.entries())
                        .sort(([, a], [, b]) => a.timestamp - b.timestamp)[0][0];
                    this.cache.delete(oldestKey);
                }
            }
        }

        // Crossref Service Implementation
        class CrossrefService {
            static get EMAIL() { return 'dronpancholi@gmail.com'; }
            static get BASE_URL() { return 'https://api.crossref.org/works'; }
            static get CACHE_DURATION() { return 12 * 60 * 60 * 1000; } // 12 hours
            static get MAX_RESULTS() { return 5; }
            static get POLITE_POOL() { return true; }
            
            static cache = new Map();

            static async search(query) {
                try {
                    // Check cache first
                    const cachedResult = this.getFromCache(query);
                    if (cachedResult) return cachedResult;

                    const params = new URLSearchParams({
                        query: query,
                        rows: this.MAX_RESULTS.toString(),
                        select: 'DOI,title,author,published-print,abstract,reference,type,container-title,URL,published',
                        mailto: this.EMAIL,
                        mailto: this.EMAIL
                    });

                    // Use polite pool for better rate limits
                    const headers = {
                        'User-Agent': `FP-GPT/0.3 (mailto:${this.EMAIL})`,
                    };

                    const response = await fetch(`${this.BASE_URL}?${params}`, { headers });
                    if (!response.ok) throw new Error(`Crossref API failed: ${response.status}`);

                    const data = await response.json();
                    if (!data.message?.items?.length) return null;

                    const formattedContent = this.formatResults(data.message.items);
                    
                    // Cache the result
                    if (formattedContent) {
                        this.addToCache(query, formattedContent);
                    }

                    return formattedContent;
                } catch (error) {
                    console.error('Crossref search failed:', error);
                    return null;
                }
            }

            static formatResults(items) {
                return items
                    .filter(item => item.title && item.DOI)
                    .map(item => {
                        const parts = [
                            `ðŸ“š ${Array.isArray(item.title) ? item.title[0] : item.title}`,
                            this.formatAuthors(item.author),
                            this.formatJournal(item),
                            this.formatDate(item),
                            `ðŸ” DOI: ${item.DOI}`,
                            item.URL ? `ðŸ”— URL: ${item.URL}` : null,
                            '',
                            this.formatAbstract(item.abstract),
                            '',
                            this.formatReferences(item.reference)
                        ];

                        return parts.filter(Boolean).join('\n');
                    })
                    .join('\n\n---\n\n');
            }

            static formatAuthors(authors) {
                if (!authors?.length) return null;
                const authorNames = authors
                    .map(author => {
                        const given = author.given || '';
                        const family = author.family || '';
                        return `${given} ${family}`.trim();
                    })
                    .filter(Boolean);

                if (!authorNames.length) return null;
                return `ðŸ‘¥ Authors: ${authorNames.join(', ')}`;
            }

            static formatJournal(item) {
                if (!item['container-title']?.length) return null;
                return `ðŸ“° Journal: ${Array.isArray(item['container-title']) ? 
                    item['container-title'][0] : item['container-title']}`;
            }

            static formatDate(item) {
                const date = item.published?.['date-parts']?.[0] || 
                            item['published-print']?.['date-parts']?.[0];
                if (!date) return null;
                return `ðŸ“… Published: ${date.join('-')}`;
            }

            static formatAbstract(abstract) {
                if (!abstract) return 'No abstract available';
                return `Abstract:\n${abstract}`;
            }

            static formatReferences(references) {
                if (!references?.length) return null;
                const formattedRefs = references
                    .slice(0, 3)
                    .map(ref => `â€¢ ${ref.DOI ? `[${ref.DOI}] ` : ''}${ref.unstructured || 'Reference'}`)
                    .join('\n');
                return `ðŸ“š Key References:\n${formattedRefs}`;
            }

            static getFromCache(query) {
                const cached = this.cache.get(query);
                if (cached && Date.now() - cached.timestamp < this.CACHE_DURATION) {
                    return cached.data;
                }
                return null;
            }

            static addToCache(query, data) {
                this.cache.set(query, {
                    data,
                    timestamp: Date.now()
                });

                // Clean old cache entries
                if (this.cache.size > 100) {
                    const oldestKey = Array.from(this.cache.entries())
                        .sort(([, a], [, b]) => a.timestamp - b.timestamp)[0][0];
                    this.cache.delete(oldestKey);
                }
            }
        }

        // Add this with other service implementations
        class CoreService {
            static get API_KEY() { return '8WNkqa1nKuXB8rzeCPGHlGSWPVXnKK4c'; } // Replace with your CORE API key
            static get BASE_URL() { return 'https://api.core.ac.uk/v3'; }
            static get CACHE_DURATION() { return 12 * 60 * 60 * 1000; } // 12 hours
            static get MAX_RESULTS() { return 5; }
            static get BATCH_SIZE() { return 2; }
            
            static cache = new Map();

            static async search(query) {
                try {
                    // Check cache first
                    const cachedResult = this.getFromCache(query);
                    if (cachedResult) return cachedResult;

                    // Search papers
                    const papers = await this.searchPapers(query);
                    if (!papers?.length) return null;

                    // Fetch full details in batches
                    const detailedPapers = await this.fetchDetailedPapers(papers);
                    
                    // Format and cache results
                    const formattedContent = this.formatResults(detailedPapers);
                    if (formattedContent) {
                        this.addToCache(query, formattedContent);
                    }

                    return formattedContent;
                } catch (error) {
                    console.error('CORE search failed:', error);
                    return null;
                }
            }

            static async searchPapers(query) {
                const headers = {
                    'Authorization': `Bearer ${this.API_KEY}`,
                    'Content-Type': 'application/json'
                };

                const body = {
                    query: query,
                    page: 1,
                    pageSize: this.MAX_RESULTS,
                    limit: this.MAX_RESULTS,
                    offset: 0,
                    filters: {
                        openAccess: true
                    }
                };

                try {
                    const response = await fetch(`${this.BASE_URL}/search/works`, {
                        method: 'POST',
                        headers: headers,
                        body: JSON.stringify(body)
                    });

                    if (!response.ok) throw new Error(`CORE API failed: ${response.status}`);

                    const data = await response.json();
                    return data.results || [];
                } catch (error) {
                    console.error('CORE paper search failed:', error);
                    return [];
                }
            }

            static async fetchDetailedPapers(papers) {
                const detailedPapers = [];
                
                // Process papers in batches to avoid rate limits
                for (let i = 0; i < papers.length; i += this.BATCH_SIZE) {
                    const batch = papers.slice(i, i + this.BATCH_SIZE);
                    const batchPromises = batch.map(paper => this.fetchPaperDetails(paper.id));
                    
                    // Add delay between batches
                    if (i > 0) {
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    }

                    const batchResults = await Promise.allSettled(batchPromises);
                    batchResults.forEach((result, index) => {
                        if (result.status === 'fulfilled' && result.value) {
                            detailedPapers.push({
                                ...batch[index],
                                ...result.value
                            });
                        }
                    });
                }

                return detailedPapers;
            }

            static async fetchPaperDetails(paperId) {
                try {
                    const response = await fetch(`${this.BASE_URL}/works/${paperId}`, {
                        headers: {
                            'Authorization': `Bearer ${this.API_KEY}`
                        }
                    });

                    if (!response.ok) return null;
                    return await response.json();
                } catch (error) {
                    console.error(`Failed to fetch paper details for ${paperId}:`, error);
                    return null;
                }
            }

            static formatResults(papers) {
                if (!papers.length) return null;

                return papers
                    .filter(paper => paper.title)
                    .map(paper => {
                        const parts = [
                            `ðŸ“‘ ${paper.title}`,
                            paper.authors?.length ? `ðŸ‘¥ Authors: ${paper.authors.map(a => a.name).join(', ')}` : null,
                            paper.publisher ? `ðŸ“° Publisher: ${paper.publisher}` : null,
                            paper.yearPublished ? `ðŸ“… Year: ${paper.yearPublished}` : null,
                            paper.doi ? `ðŸ” DOI: ${paper.doi}` : null,
                            paper.downloadUrl ? `ðŸ“¥ Download: ${paper.downloadUrl}` : null,
                            '',
                            paper.abstract ? paper.abstract.trim() : 'No abstract available',
                            '',
                            paper.topics?.length ? `ðŸ·ï¸ Topics: ${paper.topics.join(', ')}` : null,
                            paper.citations?.length ? this.formatCitations(paper.citations) : null
                        ];

                        return parts.filter(Boolean).join('\n');
                    })
                    .join('\n\n---\n\n');
            }

            static formatCitations(citations) {
                if (citations.length === 0) return null;
                const topCitations = citations.slice(0, 3);
                return 'ðŸ“š Key Citations:\n' + topCitations
                    .map(cite => `â€¢ ${cite.title || 'Citation'}`)
                    .join('\n');
            }

            static getFromCache(query) {
                const cached = this.cache.get(query);
                if (cached && Date.now() - cached.timestamp < this.CACHE_DURATION) {
                    return cached.data;
                }
                return null;
            }

            static addToCache(query, data) {
                this.cache.set(query, {
                    data,
                    timestamp: Date.now()
                });

                // Clean old cache entries
                if (this.cache.size > 100) {
                    const oldestKey = Array.from(this.cache.entries())
                        .sort(([, a], [, b]) => a.timestamp - b.timestamp)[0][0];
                    this.cache.delete(oldestKey);
                }
            }
        }

        // Add this with other service implementations
        class OpenCitationsService {
            static get BASE_URL() { return 'https://opencitations.net/index/api/v1'; }
            static get CACHE_DURATION() { return 24 * 60 * 60 * 1000; } // 24 hours
            static get MAX_RESULTS() { return 5; }
            static get BATCH_SIZE() { return 3; }
            
            static cache = new Map();

            static async search(query) {
                try {
                    // Check cache first
                    const cachedResult = this.getFromCache(query);
                    if (cachedResult) return cachedResult;

                    // First get DOIs from Crossref
                    const dois = await this.findDOIs(query);
                    if (!dois.length) return null;

                    // Get citation data
                    const citationData = await this.fetchCitationData(dois);
                    if (!citationData.length) return null;

                    // Get metadata for cited papers
                    const enrichedData = await this.enrichCitationData(citationData);
                    
                    // Format and cache results
                    const formattedContent = this.formatResults(enrichedData);
                    if (formattedContent) {
                        this.addToCache(query, formattedContent);
                    }

                    return formattedContent;
                } catch (error) {
                    console.error('OpenCitations search failed:', error);
                    return null;
                }
            }

            static async findDOIs(query) {
                try {
                    const params = new URLSearchParams({
                        q: query,
                        rows: this.MAX_RESULTS.toString(),
                        select: 'DOI,title',
                        mailto: 'dronpancholi@gmail.com'
                    });

                    const response = await fetch(`https://api.crossref.org/works?${params}`);
                    const data = await response.json();

                    return data.message.items
                        .filter(item => item.DOI)
                        .map(item => item.DOI);
                } catch (error) {
                    console.error('DOI search failed:', error);
                    return [];
                }
            }

            static async fetchCitationData(dois) {
                const citations = [];
                
                // Process DOIs in batches
                for (let i = 0; i < dois.length; i += this.BATCH_SIZE) {
                    const batch = dois.slice(i, i + this.BATCH_SIZE);
                    
                    // Add delay between batches
                    if (i > 0) {
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    }

                    const batchPromises = batch.map(doi => this.fetchCitations(doi));
                    const batchResults = await Promise.allSettled(batchPromises);
                    
                    batchResults.forEach((result, index) => {
                        if (result.status === 'fulfilled' && result.value) {
                            citations.push({
                                doi: batch[index],
                                citations: result.value
                            });
                        }
                    });
                }

                return citations;
            }

            static async fetchCitations(doi) {
                try {
                    // Get citations for a paper
                    const response = await fetch(`${this.BASE_URL}/citations/${doi}`);
                    if (!response.ok) return null;

                    const data = await response.json();
                    return data.filter(citation => citation.cited && citation.citing);
                } catch (error) {
                    console.error(`Failed to fetch citations for ${doi}:`, error);
                    return null;
                }
            }

            static async enrichCitationData(citationData) {
                const enriched = [];

                for (const paper of citationData) {
                    try {
                        // Get metadata for the main paper
                        const paperMetadata = await this.fetchPaperMetadata(paper.doi);
                        if (!paperMetadata) continue;

                        // Get metadata for citing papers
                        const citingPapers = await Promise.all(
                            paper.citations
                                .slice(0, 5) // Limit to top 5 citations
                                .map(citation => this.fetchPaperMetadata(citation.citing))
                        );

                        enriched.push({
                            ...paperMetadata,
                            citingPapers: citingPapers.filter(Boolean)
                        });
                    } catch (error) {
                        console.error(`Failed to enrich data for ${paper.doi}:`, error);
                    }
                }

                return enriched;
            }

            static async fetchPaperMetadata(doi) {
                try {
                    const response = await fetch(`https://api.crossref.org/works/${doi}`);
                    if (!response.ok) return null;

                    const data = await response.json();
                    const work = data.message;

                    return {
                        doi: work.DOI,
                        title: Array.isArray(work.title) ? work.title[0] : work.title,
                        authors: work.author?.map(a => `${a.given} ${a.family}`).join(', '),
                        year: work.published?.['date-parts']?.[0]?.[0],
                        journal: work['container-title']?.[0],
                        citations: work['is-referenced-by-count'] || 0
                    };
                } catch (error) {
                    console.error(`Failed to fetch metadata for ${doi}:`, error);
                    return null;
                }
            }

            static formatResults(papers) {
                if (!papers.length) return null;

                return papers.map(paper => {
                    const parts = [
                        `ðŸ“„ ${paper.title}`,
                        paper.authors ? `ðŸ‘¥ Authors: ${paper.authors}` : null,
                        paper.journal ? `ðŸ“° Journal: ${paper.journal}` : null,
                        paper.year ? `ðŸ“… Year: ${paper.year}` : null,
                        `ðŸ“š Total Citations: ${paper.citations}`,
                        `ðŸ” DOI: ${paper.doi}`,
                        '',
                        'ðŸ“Ž Key Citing Papers:'
                    ];

                    // Add citing papers
                    if (paper.citingPapers?.length) {
                        paper.citingPapers.forEach(citing => {
                            parts.push(
                                `â€¢ ${citing.title} (${citing.year})`,
                                `  Authors: ${citing.authors}`,
                                `  DOI: ${citing.doi}`,
                                ''
                            );
                        });
                    } else {
                        parts.push('No recent citations found.');
                    }

                    return parts.filter(Boolean).join('\n');
                }).join('\n\n---\n\n');
            }

            static getFromCache(query) {
                const cached = this.cache.get(query);
                if (cached && Date.now() - cached.timestamp < this.CACHE_DURATION) {
                    return cached.data;
                }
                return null;
            }

            static addToCache(query, data) {
                this.cache.set(query, {
                    data,
                    timestamp: Date.now()
                });

                // Clean old cache entries
                if (this.cache.size > 100) {
                    const oldestKey = Array.from(this.cache.entries())
                        .sort(([, a], [, b]) => a.timestamp - b.timestamp)[0][0];
                    this.cache.delete(oldestKey);
                }
            }
        }

        // Add this with other service implementations
        class PublicApisService {
            static get BASE_URL() { return 'https://api.publicapis.org'; }
            static get CACHE_DURATION() { return 6 * 60 * 60 * 1000; } // 6 hours
            static get MAX_RESULTS() { return 10; }
            
            static cache = new Map();

            static async search(query) {
                try {
                    // Check cache first
                    const cachedResult = this.getFromCache(query);
                    if (cachedResult) return cachedResult;

                    // Search for APIs
                    const apis = await this.searchApis(query);
                    if (!apis?.length) return null;

                    // Get categories for context
                    const categories = await this.getCategories();
                    
                    // Format and cache results
                    const formattedContent = this.formatResults(apis, categories);
                    if (formattedContent) {
                        this.addToCache(query, formattedContent);
                    }

                    return formattedContent;
                } catch (error) {
                    console.error('Public APIs search failed:', error);
                    return null;
                }
            }

            static async searchApis(query) {
                try {
                    // First try title search
                    const titleResults = await this.fetchApis(`/entries?title=${encodeURIComponent(query)}`);
                    
                    // If no results, try description search
                    if (!titleResults.length) {
                        const descResults = await this.fetchApis(`/entries?description=${encodeURIComponent(query)}`);
                        if (!descResults.length) {
                            // Try category search as last resort
                            return await this.fetchApis(`/entries?category=${encodeURIComponent(query)}`);
                        }
                        return descResults;
                    }
                    return titleResults;
                } catch (error) {
                    console.error('API search failed:', error);
                    return [];
                }
            }

            static async fetchApis(endpoint) {
                try {
                    const response = await fetch(`${this.BASE_URL}${endpoint}`);
                    if (!response.ok) throw new Error(`API request failed: ${response.status}`);

                    const data = await response.json();
                    return data.entries?.slice(0, this.MAX_RESULTS) || [];
                } catch (error) {
                    console.error('API fetch failed:', error);
                    return [];
                }
            }

            static async getCategories() {
                try {
                    const response = await fetch(`${this.BASE_URL}/categories`);
                    if (!response.ok) return [];

                    const data = await response.json();
                    return data.categories || [];
                } catch (error) {
                    console.error('Categories fetch failed:', error);
                    return [];
                }
            }

            static formatResults(apis, categories) {
                if (!apis.length) return null;

                // Group APIs by category
                const groupedApis = this.groupByCategory(apis);
                
                const sections = [];

                // Add overview section
                sections.push(
                    'ðŸ” Available APIs Overview:',
                    `Found ${apis.length} relevant APIs in ${Object.keys(groupedApis).length} categories\n`
                );

                // Add each category section
                Object.entries(groupedApis).forEach(([category, categoryApis]) => {
                    sections.push(
                        `ðŸ“ Category: ${category}`,
                        ...categoryApis.map(api => this.formatApiEntry(api))
                    );
                });

                // Add related categories section if available
                if (categories.length) {
                    const relatedCategories = categories
                        .filter(cat => !Object.keys(groupedApis).includes(cat))
                        .slice(0, 5);

                    if (relatedCategories.length) {
                        sections.push(
                            '\nðŸ·ï¸ Related Categories:',
                            relatedCategories.map(cat => `â€¢ ${cat}`).join('\n')
                        );
                    }
                }

                return sections.join('\n\n');
            }

            static formatApiEntry(api) {
                const parts = [
                    `ðŸ“Œ ${api.API}`,
                    `ðŸ“ Description: ${api.Description}`,
                    `ðŸ”— URL: ${api.Link}`,
                    `ðŸ”’ Auth: ${api.Auth || 'None'}`,
                    `ðŸ’» HTTPS: ${api.HTTPS ? 'Yes' : 'No'}`,
                    api.Cors ? `ðŸŒ CORS: ${api.Cors}` : null
                ];

                return parts.filter(Boolean).join('\n');
            }

            static groupByCategory(apis) {
                return apis.reduce((groups, api) => {
                    const category = api.Category || 'Uncategorized';
                    if (!groups[category]) {
                        groups[category] = [];
                    }
                    groups[category].push(api);
                    return groups;
                }, {});
            }

            static getFromCache(query) {
                const cached = this.cache.get(query);
                if (cached && Date.now() - cached.timestamp < this.CACHE_DURATION) {
                    return cached.data;
                }
                return null;
            }

            static addToCache(query, data) {
                this.cache.set(query, {
                    data,
                    timestamp: Date.now()
                });

                // Clean old cache entries
                if (this.cache.size > 100) {
                    const oldestKey = Array.from(this.cache.entries())
                        .sort(([, a], [, b]) => a.timestamp - b.timestamp)[0][0];
                    this.cache.delete(oldestKey);
                }
            }
        }

        // Add this with other service implementations
        class GitHubService {
            static get TOKEN() { 
                // You can set your token here or load it from environment/config
                return 'YOUR_GITHUB_TOKEN'; 
            }

            static get headers() {
                // Use Bearer for JWT tokens, token for personal access tokens
                const authPrefix = this.TOKEN.includes('.') ? 'Bearer' : 'token';
                
                return {
                    'Authorization': `${authPrefix} ${this.TOKEN}`,
                    'Accept': 'application/vnd.github+json',
                    'X-GitHub-Api-Version': '2022-11-28',
                    'User-Agent': 'FP-GPT'
                };
            }

            static validateToken() {
                if (!this.TOKEN || this.TOKEN === 'YOUR_GITHUB_TOKEN') {
                    console.warn('GitHub token not configured. Some API calls may be rate limited.');
                    return false;
                }
                return true;
            }

            static async search(query) {
                try {
                    // Validate token before making requests
                    this.validateToken();

                    const cachedResult = this.getFromCache(query);
                    if (cachedResult) return cachedResult;

                    const searchResults = await this.searchRepositories(query);
                    if (!searchResults?.items?.length) return null;

                    // Add rate limit handling
                    const rateLimit = await this.checkRateLimit();
                    if (!rateLimit.remaining) {
                        console.warn(`GitHub API rate limit reached. Resets at ${new Date(rateLimit.reset * 1000)}`);
                        return 'Rate limit reached for GitHub API. Please try again later.';
                    }

                    const enrichedRepos = await Promise.all(
                        searchResults.items.slice(0, this.MAX_RESULTS)
                            .map(repo => this.getRepositoryDetails(repo.full_name))
                    );

                    const formattedContent = this.formatResults(enrichedRepos.filter(Boolean));
                    if (formattedContent) {
                        this.addToCache(query, formattedContent);
                    }

                    return formattedContent;
                } catch (error) {
                    console.error('GitHub search failed:', error);
                    return null;
                }
            }

            static async checkRateLimit() {
                try {
                    const response = await fetch(`${this.BASE_URL}/rate_limit`, {
                        headers: this.headers
                    });
                    
                    if (!response.ok) return { remaining: 0, reset: 0 };
                    
                    const data = await response.json();
                    return {
                        remaining: data.rate.remaining,
                        reset: data.rate.reset
                    };
                } catch (error) {
                    console.error('Failed to check rate limit:', error);
                    return { remaining: 0, reset: 0 };
                }
            }

            static async searchRepositories(query) {
                try {
                    const params = new URLSearchParams({
                        q: query,
                        sort: 'stars',
                        order: 'desc',
                        per_page: this.MAX_RESULTS
                    });

                    const response = await fetch(
                        `${this.BASE_URL}/search/repositories?${params}`,
                        { headers: this.headers }
                    );

                    if (response.status === 401) {
                        throw new Error('GitHub API authentication failed. Please check your token.');
                    }
                    if (response.status === 403) {
                        throw new Error('GitHub API rate limit exceeded.');
                    }
                    if (!response.ok) {
                        throw new Error(`GitHub API request failed: ${response.status}`);
                    }

                    return await response.json();
                } catch (error) {
                    console.error('GitHub repository search failed:', error);
                    throw error; // Propagate error for proper handling
                }
            }

            static async getRepositoryDetails(fullName) {
                try {
                    const [repo, readme, releases, issues, contributors] = await Promise.all([
                        this.fetchRepoData(fullName),
                        this.fetchReadme(fullName),
                        this.fetchReleases(fullName),
                        this.fetchIssues(fullName),
                        this.fetchContributors(fullName)
                    ]);

                    if (!repo) return null;

                    return {
                        ...repo,
                        readme,
                        releases,
                        issues,
                        contributors
                    };
                } catch (error) {
                    console.error(`Failed to get details for ${fullName}:`, error);
                    return null;
                }
            }

            static async fetchRepoData(fullName) {
                const response = await fetch(
                    `${this.BASE_URL}/repos/${fullName}`,
                    { headers: this.headers }
                );
                return response.ok ? response.json() : null;
            }

            static async fetchReadme(fullName) {
                const response = await fetch(
                    `${this.BASE_URL}/repos/${fullName}/readme`,
                    { headers: { ...this.headers, 'Accept': 'application/vnd.github.raw' } }
                );
                return response.ok ? response.text() : null;
            }

            static async fetchReleases(fullName) {
                const response = await fetch(
                    `${this.BASE_URL}/repos/${fullName}/releases?per_page=3`,
                    { headers: this.headers }
                );
                return response.ok ? response.json() : [];
            }

            static async fetchIssues(fullName) {
                const response = await fetch(
                    `${this.BASE_URL}/repos/${fullName}/issues?state=open&per_page=3`,
                    { headers: this.headers }
                );
                return response.ok ? response.json() : [];
            }

            static async fetchContributors(fullName) {
                const response = await fetch(
                    `${this.BASE_URL}/repos/${fullName}/contributors?per_page=5`,
                    { headers: this.headers }
                );
                return response.ok ? response.json() : [];
            }

            static formatResults(repos) {
                if (!repos.length) return null;

                return repos.map(repo => {
                    const parts = [
                        `â­ ${repo.stargazers_count.toLocaleString()} | ${repo.full_name}`,
                        `ðŸ“ ${repo.description || 'No description available'}`,
                        repo.language ? `ðŸ’» Primary Language: ${repo.language}` : null,
                        repo.license?.name ? `ðŸ“œ License: ${repo.license.name}` : null,
                        '',
                        `ðŸ“Š Statistics:`,
                        `â€¢ Stars: ${repo.stargazers_count.toLocaleString()}`,
                        `â€¢ Forks: ${repo.forks_count.toLocaleString()}`,
                        `â€¢ Watchers: ${repo.subscribers_count.toLocaleString()}`,
                        `â€¢ Open Issues: ${repo.open_issues_count.toLocaleString()}`,
                        '',
                        this.formatReadme(repo.readme),
                        '',
                        this.formatReleases(repo.releases),
                        this.formatIssues(repo.issues),
                        this.formatContributors(repo.contributors),
                        '',
                        `ðŸ”— Repository: ${repo.html_url}`,
                        repo.homepage ? `ðŸŒ Homepage: ${repo.homepage}` : null
                    ];

                    return parts.filter(Boolean).join('\n');
                }).join('\n\n---\n\n');
            }

            static formatReadme(readme) {
                if (!readme) return null;
                const summary = readme
                    .split('\n')
                    .map(line => line.trim())
                    .filter(line => line && !line.startsWith('#') && !line.startsWith('!'))
                    [0];
                return summary ? `ðŸ“– From README:\n${summary.substring(0, 300)}...` : null;
            }

            static formatReleases(releases) {
                if (!releases?.length) return null;
                return [
                    'ðŸ·ï¸ Latest Releases:',
                    ...releases.map(release => 
                        `â€¢ ${release.tag_name}: ${release.name || 'No title'}`
                    )
                ].join('\n');
            }

            static formatIssues(issues) {
                if (!issues?.length) return null;
                return [
                    'ðŸ› Recent Issues:',
                    ...issues.map(issue => 
                        `â€¢ ${issue.title} (#${issue.number}`
                    )
                ].join('\n');
            }

            static formatContributors(contributors) {
                if (!contributors?.length) return null;
                return [
                    'ðŸ‘¥ Top Contributors:',
                    ...contributors.map(contributor =>
                        `â€¢ ${contributor.login} (${contributor.contributions} contributions)`
                    )
                ].join('\n');
            }

            static getFromCache(query) {
                const cached = this.cache.get(query);
                if (cached && Date.now() - cached.timestamp < this.CACHE_DURATION) {
                    return cached.data;
                }
                return null;
            }

            static addToCache(query, data) {
                this.cache.set(query, {
                    data,
                    timestamp: Date.now()
                });

                // Clean old cache entries
                if (this.cache.size > 100) {
                    const oldestKey = Array.from(this.cache.entries())
                        .sort(([, a], [, b]) => a.timestamp - b.timestamp)[0][0];
                    this.cache.delete(oldestKey);
                }
            }
        }

        // Add this with other service implementations
        class StackExchangeService {
            static get API_KEY() { return 'YOUR_STACK_EXCHANGE_KEY'; }
            static get BASE_URL() { return 'https://api.stackexchange.com/2.3'; }
            static get CACHE_DURATION() { return 15 * 60 * 1000; } // 15 minutes
            static get MAX_RESULTS() { return 5; }
            static get SITES() { return [
                'stackoverflow',
                'softwareengineering',
                'ai',
                'datascience',
                'stats'
            ]};
            
            static cache = new Map();

            static async search(query) {
                try {
                    const cachedResult = this.getFromCache(query);
                    if (cachedResult) return cachedResult;

                    // Search across multiple Stack Exchange sites
                    const results = await this.searchAllSites(query);
                    if (!results?.length) return null;

                    // Get detailed information including answers
                    const enrichedResults = await this.enrichQuestions(results);
                    
                    const formattedContent = this.formatResults(enrichedResults);
                    if (formattedContent) {
                        this.addToCache(query, formattedContent);
                    }

                    return formattedContent;
                } catch (error) {
                    console.error('Stack Exchange search failed:', error);
                    return null;
                }
            }

            static async searchAllSites(query) {
                const allResults = [];

                // Search each site in parallel
                const siteResults = await Promise.all(
                    this.SITES.map(site => this.searchSite(query, site))
                );

                // Combine and sort results by score
                siteResults.flat()
                    .sort((a, b) => b.score - a.score)
                    .slice(0, this.MAX_RESULTS)
                    .forEach(result => allResults.push(result));

                return allResults;
            }

            static async searchSite(query, site) {
                try {
                    const params = new URLSearchParams({
                        site,
                        q: query,
                        pagesize: '10',
                        order: 'desc',
                        sort: 'votes',
                        filter: 'withbody',
                        key: this.API_KEY
                    });

                    const response = await fetch(
                        `${this.BASE_URL}/search/advanced?${params}`
                    );

                    if (!response.ok) {
                        throw new Error(`Stack Exchange API failed: ${response.status}`);
                    }

                    const data = await response.json();
                    
                    // Check quota
                    if (data.quota_remaining === 0) {
                        console.warn(`Stack Exchange API quota exceeded. Resets at ${new Date(data.quota_max * 1000)}`);
                        return [];
                    }

                    return data.items.map(item => ({
                        ...item,
                        site
                    }));
                } catch (error) {
                    console.error(`Failed to search ${site}:`, error);
                    return [];
                }
            }

            static async enrichQuestions(questions) {
                const enriched = [];

                for (const question of questions) {
                    try {
                        // Get answers for the question
                        const answers = await this.fetchAnswers(question.question_id, question.site);
                        
                        enriched.push({
                            ...question,
                            answers: answers.slice(0, 2) // Get top 2 answers
                        });
                    } catch (error) {
                        console.error(`Failed to enrich question ${question.question_id}:`, error);
                        enriched.push(question);
                    }
                }

                return enriched;
            }

            static async fetchAnswers(questionId, site) {
                try {
                    const params = new URLSearchParams({
                        site,
                        order: 'desc',
                        sort: 'votes',
                        filter: 'withbody',
                        pagesize: '2',
                        key: this.API_KEY
                    });

                    const response = await fetch(
                        `${this.BASE_URL}/questions/${questionId}/answers?${params}`
                    );

                    if (!response.ok) return [];

                    const data = await response.json();
                    return data.items || [];
                } catch (error) {
                    console.error(`Failed to fetch answers for ${questionId}:`, error);
                    return [];
                }
            }

            static formatResults(questions) {
                if (!questions.length) return null;

                return questions.map(question => {
                    const parts = [
                        `ðŸ“ ${this.decodeHtml(question.title)}`,
                        `ðŸ¢ From ${question.site}`,
                        `ðŸ‘¤ Asked by ${question.owner.display_name}`,
                        `ðŸ“Š Score: ${question.score} | ðŸ‘ï¸ Views: ${question.view_count}`,
                        '',
                        this.formatBody(question.body),
                        '',
                        question.answers?.length ? this.formatAnswers(question.answers) : 'âŒ No answers yet',
                        '',
                        `ðŸ”— Link: ${question.link}`,
                        question.tags?.length ? `ðŸ·ï¸ Tags: ${question.tags.join(', ')}` : null
                    ];

                    return parts.filter(Boolean).join('\n');
                }).join('\n\n---\n\n');
            }

            static formatBody(body) {
                if (!body) return null;
                // Convert HTML to plain text and limit length
                const text = this.decodeHtml(body)
                    .replace(/<[^>]*>/g, '')
                    .replace(/\s+/g, ' ')
                    .trim();
                return text.length > 300 ? text.substring(0, 300) + '...' : text;
            }

            static formatAnswers(answers) {
                if (!answers.length) return null;
                return [
                    'âœ… Top Answers:',
                    ...answers.map(answer => [
                        `Score: ${answer.score}`,
                        this.formatBody(answer.body),
                        `Answered by: ${answer.owner.display_name}`
                    ].join('\n'))
                ].join('\n\n');
            }

            static decodeHtml(html) {
                const txt = document.createElement('textarea');
                txt.innerHTML = html;
                return txt.value;
            }

            static getFromCache(query) {
                const cached = this.cache.get(query);
                if (cached && Date.now() - cached.timestamp < this.CACHE_DURATION) {
                    return cached.data;
                }
                return null;
            }

            static addToCache(query, data) {
                this.cache.set(query, {
                    data,
                    timestamp: Date.now()
                });

                // Clean old cache entries
                if (this.cache.size > 100) {
                    const oldestKey = Array.from(this.cache.entries())
                        .sort(([, a], [, b]) => a.timestamp - b.timestamp)[0][0];
                    this.cache.delete(oldestKey);
                }
            }
        }

        // Add this with other service implementations
        class RapidApiService {
            static get API_KEY() { return 'YOUR_RAPIDAPI_KEY'; }
            static get CACHE_DURATION() { return 60 * 60 * 1000; } // 1 hour
            static get MAX_RESULTS() { return 5; }
            static get CATEGORIES() { return [
                'Tools', 'Entertainment', 'Finance', 'Weather',
                'AI', 'Education', 'Health', 'Science'
            ]};
            
            static cache = new Map();

            static async search(query) {
                try {
                    const cachedResult = this.getFromCache(query);
                    if (cachedResult) return cachedResult;

                    // Search APIs and collections
                    const [apis, collections] = await Promise.all([
                        this.searchApis(query),
                        this.searchCollections(query)
                    ]);

                    // Get detailed information
                    const enrichedResults = await this.enrichResults(apis, collections);
                    
                    const formattedContent = this.formatResults(enrichedResults);
                    if (formattedContent) {
                        this.addToCache(query, formattedContent);
                    }

                    return formattedContent;
                } catch (error) {
                    console.error('RapidAPI search failed:', error);
                    return null;
                }
            }

            static async searchApis(query) {
                try {
                    const response = await fetch('https://rapidapi.com/search/api', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-RapidAPI-Key': this.API_KEY,
                            'X-RapidAPI-Host': 'rapidapi.com'
                        },
                        body: JSON.stringify({
                            query: query,
                            page: 1,
                            limit: this.MAX_RESULTS
                        })
                    });

                    if (!response.ok) throw new Error(`API search failed: ${response.status}`);
                    const data = await response.json();
                    return data.results || [];
                } catch (error) {
                    console.error('API search failed:', error);
                    return [];
                }
            }

            static async searchCollections(query) {
                try {
                    const response = await fetch('https://rapidapi.com/search/collection', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-RapidAPI-Key': this.API_KEY,
                            'X-RapidAPI-Host': 'rapidapi.com'
                        },
                        body: JSON.stringify({
                            query: query,
                            page: 1,
                            limit: this.MAX_RESULTS
                        })
                    });

                    if (!response.ok) throw new Error(`Collection search failed: ${response.status}`);
                    const data = await response.json();
                    return data.results || [];
                } catch (error) {
                    console.error('Collection search failed:', error);
                    return [];
                }
            }

            static async enrichResults(apis, collections) {
                const enriched = {
                    apis: await this.enrichApis(apis),
                    collections: await this.enrichCollections(collections)
                };

                // Add category recommendations
                enriched.recommendations = this.getRecommendations(
                    [...apis, ...collections]
                );

                return enriched;
            }

            static async enrichApis(apis) {
                return Promise.all(apis.map(async api => {
                    try {
                        const details = await this.fetchApiDetails(api.id);
                        return {
                            ...api,
                            ...details,
                            type: 'api'
                        };
                    } catch (error) {
                        console.error(`Failed to enrich API ${api.id}:`, error);
                        return { ...api, type: 'api' };
                    }
                }));
            }

            static async enrichCollections(collections) {
                return Promise.all(collections.map(async collection => {
                    try {
                        const details = await this.fetchCollectionDetails(collection.id);
                        return {
                            ...collection,
                            ...details,
                            type: 'collection'
                        };
                    } catch (error) {
                        console.error(`Failed to enrich collection ${collection.id}:`, error);
                        return { ...collection, type: 'collection' };
                    }
                }));
            }

            static async fetchApiDetails(apiId) {
                try {
                    const response = await fetch(`https://rapidapi.com/api/${apiId}`, {
                        headers: {
                            'X-RapidAPI-Key': this.API_KEY,
                            'X-RapidAPI-Host': 'rapidapi.com'
                        }
                    });

                    if (!response.ok) return {};
                    return await response.json();
                } catch (error) {
                    console.error(`Failed to fetch API details for ${apiId}:`, error);
                    return {};
                }
            }

            static async fetchCollectionDetails(collectionId) {
                try {
                    const response = await fetch(`https://rapidapi.com/collection/${collectionId}`, {
                        headers: {
                            'X-RapidAPI-Key': this.API_KEY,
                            'X-RapidAPI-Host': 'rapidapi.com'
                        }
                    });

                    if (!response.ok) return {};
                    return await response.json();
                } catch (error) {
                    console.error(`Failed to fetch collection details for ${collectionId}:`, error);
                    return {};
                }
            }

            static getRecommendations(items) {
                const categories = new Map();
                
                // Count category occurrences
                items.forEach(item => {
                    if (item.category) {
                        const count = categories.get(item.category) || 0;
                        categories.set(item.category, count + 1);
                    }
                });

                // Get top categories
                return Array.from(categories.entries())
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 3)
                    .map(([category]) => category);
            }

            static formatResults(results) {
                const parts = [];

                // Add overview
                parts.push(
                    'ðŸ” RapidAPI Search Results',
                    `Found ${results.apis.length} APIs and ${results.collections.length} collections\n`
                );

                // Format APIs
                if (results.apis.length) {
                    parts.push('ðŸ“¡ Available APIs:');
                    results.apis.forEach(api => {
                        parts.push(this.formatApi(api));
                    });
                }

                // Format Collections
                if (results.collections.length) {
                    parts.push('\nðŸ“š Related Collections:');
                    results.collections.forEach(collection => {
                        parts.push(this.formatCollection(collection));
                    });
                }

                // Add recommendations
                if (results.recommendations.length) {
                    parts.push(
                        '\nðŸ’¡ Recommended Categories:',
                        results.recommendations.map(cat => `â€¢ ${cat}`).join('\n')
                    );
                }

                return parts.join('\n');
            }

            static formatApi(api) {
                const parts = [
                    `\nðŸ”¹ ${api.name}`,
                    api.description ? `ðŸ“ ${api.description}` : null,
                    api.category ? `ðŸ·ï¸ Category: ${api.category}` : null,
                    api.pricing?.type ? `ðŸ’° Pricing: ${api.pricing.type}` : null,
                    api.specs?.auth ? `ðŸ”’ Auth: ${api.specs.auth}` : null,
                    api.stats ? `ðŸ“Š Usage: ${api.stats.subscribers} subscribers` : null,
                    api.url ? `ðŸ”— Link: ${api.url}` : null
                ];

                return parts.filter(Boolean).join('\n');
            }

            static formatCollection(collection) {
                const parts = [
                    `\nðŸ“ ${collection.name}`,
                    collection.description ? `ðŸ“ ${collection.description}` : null,
                    collection.apiCount ? `ðŸ“Š APIs: ${collection.apiCount}` : null,
                    collection.category ? `ðŸ·ï¸ Category: ${collection.category}` : null,
                    collection.url ? `ðŸ”— Link: ${collection.url}` : null
                ];

                return parts.filter(Boolean).join('\n');
            }

            static getFromCache(query) {
                const cached = this.cache.get(query);
                if (cached && Date.now() - cached.timestamp < this.CACHE_DURATION) {
                    return cached.data;
                }
                return null;
            }

            static addToCache(query, data) {
                this.cache.set(query, {
                    data,
                    timestamp: Date.now()
                });

                if (this.cache.size > 100) {
                    const oldestKey = Array.from(this.cache.entries())
                        .sort(([, a], [, b]) => a.timestamp - b.timestamp)[0][0];
                    this.cache.delete(oldestKey);
                }
            }
        }

        // Add this with other service implementations
        class PostmanService {
            static get API_KEY() { return 'PMAK-YOUR-POSTMAN-API-KEY'; }
            static get BASE_URL() { return 'https://api.getpostman.com'; }
            static get CACHE_DURATION() { return 2 * 60 * 60 * 1000; } // 2 hours
            static get MAX_RESULTS() { return 5; }
            static get MAX_REQUESTS() { return 3; }
            
            static cache = new Map();

            static async search(query) {
                try {
                    const cachedResult = this.getFromCache(query);
                    if (cachedResult) return cachedResult;

                    // Search collections and workspaces
                    const [collections, workspaces] = await Promise.all([
                        this.searchCollections(query),
                        this.searchWorkspaces(query)
                    ]);

                    // Get detailed information
                    const enrichedResults = await this.enrichResults(collections, workspaces);
                    
                    const formattedContent = this.formatResults(enrichedResults);
                    if (formattedContent) {
                        this.addToCache(query, formattedContent);
                    }

                    return formattedContent;
                } catch (error) {
                    console.error('Postman search failed:', error);
                    return null;
                }
            }

            static async searchCollections(query) {
                try {
                    const response = await fetch(`${this.BASE_URL}/collections?query=${encodeURIComponent(query)}`, {
                        headers: {
                            'X-API-Key': this.API_KEY,
                            'Content-Type': 'application/json'
                        }
                    });

                    if (!response.ok) throw new Error(`Collection search failed: ${response.status}`);
                    const data = await response.json();
                    return data.collections?.slice(0, this.MAX_RESULTS) || [];
                } catch (error) {
                    console.error('Collection search failed:', error);
                    return [];
                }
            }

            static async searchWorkspaces(query) {
                try {
                    const response = await fetch(`${this.BASE_URL}/workspaces?query=${encodeURIComponent(query)}`, {
                        headers: {
                            'X-API-Key': this.API_KEY,
                            'Content-Type': 'application/json'
                        }
                    });

                    if (!response.ok) throw new Error(`Workspace search failed: ${response.status}`);
                    const data = await response.json();
                    return data.workspaces?.slice(0, this.MAX_RESULTS) || [];
                } catch (error) {
                    console.error('Workspace search failed:', error);
                    return [];
                }
            }

            static async enrichResults(collections, workspaces) {
                const enriched = {
                    collections: await this.enrichCollections(collections),
                    workspaces: await this.enrichWorkspaces(workspaces)
                };

                // Add documentation and examples
                enriched.documentation = await this.fetchDocumentation(
                    enriched.collections.map(c => c.uid)
                );

                return enriched;
            }

            static async enrichCollections(collections) {
                return Promise.all(collections.map(async collection => {
                    try {
                        const details = await this.fetchCollectionDetails(collection.uid);
                        return {
                            ...collection,
                            ...details,
                            type: 'collection'
                        };
                    } catch (error) {
                        console.error(`Failed to enrich collection ${collection.uid}:`, error);
                        return { ...collection, type: 'collection' };
                    }
                }));
            }

            static async enrichWorkspaces(workspaces) {
                return Promise.all(workspaces.map(async workspace => {
                    try {
                        const details = await this.fetchWorkspaceDetails(workspace.id);
                        return {
                            ...workspace,
                            ...details,
                            type: 'workspace'
                        };
                    } catch (error) {
                        console.error(`Failed to enrich workspace ${workspace.id}:`, error);
                        return { ...workspace, type: 'workspace' };
                    }
                }));
            }

            static async fetchCollectionDetails(collectionId) {
                try {
                    const response = await fetch(`${this.BASE_URL}/collections/${collectionId}`, {
                        headers: {
                            'X-API-Key': this.API_KEY,
                            'Content-Type': 'application/json'
                        }
                    });

                    if (!response.ok) return {};
                    const data = await response.json();
                    return data.collection || {};
                } catch (error) {
                    console.error(`Failed to fetch collection details for ${collectionId}:`, error);
                    return {};
                }
            }

            static async fetchWorkspaceDetails(workspaceId) {
                try {
                    const response = await fetch(`${this.BASE_URL}/workspaces/${workspaceId}`, {
                        headers: {
                            'X-API-Key': this.API_KEY,
                            'Content-Type': 'application/json'
                        }
                    });

                    if (!response.ok) return {};
                    const data = await response.json();
                    return data.workspace || {};
                } catch (error) {
                    console.error(`Failed to fetch workspace details for ${workspaceId}:`, error);
                    return {};
                }
            }

            static async fetchDocumentation(collectionIds) {
                const docs = [];
                
                for (const id of collectionIds) {
                    try {
                        const response = await fetch(`${this.BASE_URL}/collections/${id}/documentation`, {
                            headers: {
                                'X-API-Key': this.API_KEY,
                                'Content-Type': 'application/json'
                            }
                        });

                        if (!response.ok) continue;
                        const data = await response.json();
                        if (data.documentation) {
                            docs.push({
                                collectionId: id,
                                content: data.documentation
                            });
                        }
                    } catch (error) {
                        console.error(`Failed to fetch documentation for ${id}:`, error);
                    }
                }

                return docs;
            }

            static formatResults(results) {
                const parts = [];

                // Add overview
                parts.push(
                    'ðŸ” Postman Search Results',
                    `Found ${results.collections.length} collections and ${results.workspaces.length} workspaces\n`
                );

                // Format Collections
                if (results.collections.length) {
                    parts.push('ðŸ“š API Collections:');
                    results.collections.forEach(collection => {
                        parts.push(this.formatCollection(collection));
                    });
                }

                // Format Workspaces
                if (results.workspaces.length) {
                    parts.push('\nðŸ¢ Public Workspaces:');
                    results.workspaces.forEach(workspace => {
                        parts.push(this.formatWorkspace(workspace));
                    });
                }

                // Add Documentation
                if (results.documentation?.length) {
                    parts.push('\nðŸ“– Documentation Highlights:');
                    results.documentation.forEach(doc => {
                        parts.push(this.formatDocumentation(doc));
                    });
                }

                return parts.join('\n');
            }

            static formatCollection(collection) {
                const parts = [
                    `\nðŸ”¹ ${collection.name}`,
                    collection.description ? `ðŸ“ ${collection.description}` : null,
                    collection.owner ? `ðŸ‘¤ Owner: ${collection.owner}` : null,
                    `ðŸ“Š Requests: ${collection.requests?.length || 0}`,
                    collection.tags?.length ? `ðŸ·ï¸ Tags: ${collection.tags.join(', ')}` : null,
                    collection.url ? `ðŸ”— Link: ${collection.url}` : null
                ];

                // Add example requests if available
                if (collection.requests?.length) {
                    parts.push(
                        '\nðŸ“¡ Example Endpoints:',
                        ...collection.requests
                            .slice(0, this.MAX_REQUESTS)
                            .map(req => `â€¢ ${req.method} ${req.path}`)
                    );
                }

                return parts.filter(Boolean).join('\n');
            }

            static formatWorkspace(workspace) {
                const parts = [
                    `\nðŸ¢ ${workspace.name}`,
                    workspace.description ? `ðŸ“ ${workspace.description}` : null,
                    workspace.type ? `ðŸ”’ Type: ${workspace.type}` : null,
                    `ðŸ“Š Collections: ${workspace.collections?.length || 0}`,
                    workspace.url ? `ðŸ”— Link: ${workspace.url}` : null
                ];

                return parts.filter(Boolean).join('\n');
            }

            static formatDocumentation(doc) {
                if (!doc.content) return null;
                const summary = doc.content.substring(0, 300);
                return `\nðŸ“– Documentation:\n${summary}${doc.content.length > 300 ? '...' : ''}`;
            }

            // Cache methods remain the same as other services...
            static getFromCache(query) {
                const cached = this.cache.get(query);
                if (cached && Date.now() - cached.timestamp < this.CACHE_DURATION) {
                    return cached.data;
                }
                return null;
            }

            static addToCache(query, data) {
                this.cache.set(query, {
                    data,
                    timestamp: Date.now()
                });

                if (this.cache.size > 100) {
                    const oldestKey = Array.from(this.cache.entries())
                        .sort(([, a], [, b]) => a.timestamp - b.timestamp)[0][0];
                    this.cache.delete(oldestKey);
                }
            }
        }

        // Add this with other service implementations
        class DBpediaService {
            static get BASE_URL() { return 'https://dbpedia.org/sparql'; }
            static get CACHE_DURATION() { return 24 * 60 * 60 * 1000; } // 24 hours
            static get MAX_RESULTS() { return 5; }
            static get DEFAULT_LANG() { return 'en'; }
            
            static cache = new Map();

            static async search(query) {
                try {
                    const cachedResult = this.getFromCache(query);
                    if (cachedResult) return cachedResult;

                    // Search entities and their properties
                    const results = await this.searchEntities(query);
                    if (!results?.length) return null;

                    // Get additional information
                    const enrichedResults = await this.enrichResults(results);
                    
                    const formattedContent = this.formatResults(enrichedResults);
                    if (formattedContent) {
                        this.addToCache(query, formattedContent);
                    }

                    return formattedContent;
                } catch (error) {
                    console.error('DBpedia search failed:', error);
                    return null;
                }
            }

            static async searchEntities(query) {
                const sparqlQuery = `
                    PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
                    PREFIX dbo: <http://dbpedia.org/ontology/>
                    PREFIX dbp: <http://dbpedia.org/property/>
                    PREFIX foaf: <http://xmlns.com/foaf/0.1/>

                    SELECT DISTINCT ?entity ?label ?abstract ?type ?thumbnail
                    WHERE {
                        ?entity rdfs:label ?label ;
                                dbo:abstract ?abstract .
                        OPTIONAL { ?entity rdf:type ?type }
                        OPTIONAL { ?entity dbo:thumbnail ?thumbnail }
                        
                        FILTER (
                            LANG(?label) = "${this.DEFAULT_LANG}" &&
                            LANG(?abstract) = "${this.DEFAULT_LANG}" &&
                            (REGEX(?label, "${query}", "i") || 
                             REGEX(?abstract, "${query}", "i"))
                        )
                    }
                    LIMIT ${this.MAX_RESULTS}
                `;

                try {
                    const params = new URLSearchParams({
                        query: sparqlQuery,
                        format: 'json'
                    });

                    const response = await fetch(`${this.BASE_URL}?${params}`);
                    if (!response.ok) throw new Error(`DBpedia query failed: ${response.status}`);

                    const data = await response.json();
                    return data.results.bindings;
                } catch (error) {
                    console.error('DBpedia entity search failed:', error);
                    return [];
                }
            }

            static async enrichResults(results) {
                return Promise.all(results.map(async result => {
                    try {
                        const entityUri = result.entity.value;
                        const [properties, categories, links] = await Promise.all([
                            this.fetchProperties(entityUri),
                            this.fetchCategories(entityUri),
                            this.fetchExternalLinks(entityUri)
                        ]);

                        return {
                            ...result,
                            properties,
                            categories,
                            links
                        };
                    } catch (error) {
                        console.error(`Failed to enrich entity ${result.entity.value}:`, error);
                        return result;
                    }
                }));
            }

            static async fetchProperties(entityUri) {
                const sparqlQuery = `
                    PREFIX dbo: <http://dbpedia.org/ontology/>
                    PREFIX dbp: <http://dbpedia.org/property/>

                    SELECT ?property ?value
                    WHERE {
                        <${entityUri}> ?property ?value .
                        FILTER (
                            STRSTARTS(STR(?property), STR(dbo:)) ||
                            STRSTARTS(STR(?property), STR(dbp:))
                        )
                        FILTER (LANG(?value) = "" || LANG(?value) = "${this.DEFAULT_LANG}")
                    }
                    LIMIT 10
                `;

                try {
                    const params = new URLSearchParams({
                        query: sparqlQuery,
                        format: 'json'
                    });

                    const response = await fetch(`${this.BASE_URL}?${params}`);
                    if (!response.ok) return [];

                    const data = await response.json();
                    return data.results.bindings;
                } catch (error) {
                    console.error(`Failed to fetch properties for ${entityUri}:`, error);
                    return [];
                }
            }

            static async fetchCategories(entityUri) {
                const sparqlQuery = `
                    PREFIX dct: <http://purl.org/dc/terms/>
                    PREFIX skos: <http://www.w3.org/2004/02/skos/core#>

                    SELECT ?category
                    WHERE {
                        <${entityUri}> dct:subject ?category .
                    }
                    LIMIT 5
                `;

                try {
                    const params = new URLSearchParams({
                        query: sparqlQuery,
                        format: 'json'
                    });

                    const response = await fetch(`${this.BASE_URL}?${params}`);
                    if (!response.ok) return [];

                    const data = await response.json();
                    return data.results.bindings;
                } catch (error) {
                    console.error(`Failed to fetch categories for ${entityUri}:`, error);
                    return [];
                }
            }

            static async fetchExternalLinks(entityUri) {
                const sparqlQuery = `
                    PREFIX owl: <http://www.w3.org/2002/07/owl#>
                    PREFIX foaf: <http://xmlns.com/foaf/0.1/>

                    SELECT ?link
                    WHERE {
                        <${entityUri}> owl:sameAs|foaf:homepage ?link .
                        FILTER (
                            STRSTARTS(STR(?link), "http://") ||
                            STRSTARTS(STR(?link), "https://")
                        )
                    }
                    LIMIT 5
                `;

                try {
                    const params = new URLSearchParams({
                        query: sparqlQuery,
                        format: 'json'
                    });

                    const response = await fetch(`${this.BASE_URL}?${params}`);
                    if (!response.ok) return [];

                    const data = await response.json();
                    return data.results.bindings;
                } catch (error) {
                    console.error(`Failed to fetch links for ${entityUri}:`, error);
                    return [];
                }
            }

            static formatResults(results) {
                if (!results.length) return null;

                return results.map(result => {
                    const parts = [
                        `ðŸ“š ${this.getValue(result.label)}`,
                        '',
                        this.getValue(result.abstract),
                        '',
                        this.formatProperties(result.properties),
                        this.formatCategories(result.categories),
                        this.formatLinks(result.links),
                        result.thumbnail ? `ðŸ–¼ï¸ Image: ${result.thumbnail.value}` : null
                    ];

                    return parts.filter(Boolean).join('\n');
                }).join('\n\n---\n\n');
            }

            static formatProperties(properties) {
                if (!properties?.length) return null;

                const formattedProps = properties
                    .map(prop => {
                        const propertyName = this.getPropertyName(prop.property.value);
                        const value = this.getValue(prop.value);
                        return `â€¢ ${propertyName}: ${value}`;
                    })
                    .filter(Boolean);

                return formattedProps.length ? `ðŸ“ Properties:\n${formattedProps.join('\n')}` : null;
            }

            static formatCategories(categories) {
                if (!categories?.length) return null;

                const formattedCats = categories
                    .map(cat => this.getCategoryName(cat.category.value))
                    .filter(Boolean);

                return formattedCats.length ? `ðŸ·ï¸ Categories:\n${formattedCats.join(', ')}` : null;
            }

            static formatLinks(links) {
                if (!links?.length) return null;

                const formattedLinks = links
                    .map(link => `â€¢ ${link.link.value}`)
                    .filter(Boolean);

                return formattedLinks.length ? `ðŸ”— Related Links:\n${formattedLinks.join('\n')}` : null;
            }

            static getValue(binding) {
                return binding?.value || '';
            }

            static getPropertyName(uri) {
                const match = uri.match(/[/#]([^/#]+)$/);
                return match ? match[1].replace(/([A-Z])/g, ' $1').trim() : uri;
            }

            static getCategoryName(uri) {
                const match = uri.match(/Category:(.+)$/);
                return match ? match[1].replace(/_/g, ' ') : uri;
            }

            // Cache methods remain the same as other services...
            static getFromCache(query) {
                const cached = this.cache.get(query);
                if (cached && Date.now() - cached.timestamp < this.CACHE_DURATION) {
                    return cached.data;
                }
                return null;
            }

            static addToCache(query, data) {
                this.cache.set(query, {
                    data,
                    timestamp: Date.now()
                });

                if (this.cache.size > 100) {
                    const oldestKey = Array.from(this.cache.entries())
                        .sort(([, a], [, b]) => a.timestamp - b.timestamp)[0][0];
                    this.cache.delete(oldestKey);
                }
            }
        }

        // Add this with other service implementations
        class OpenLibraryService {
            static get BASE_URL() { return 'https://openlibrary.org/api'; }
            static get SEARCH_URL() { return 'https://openlibrary.org/search.json'; }
            static get CACHE_DURATION() { return 12 * 60 * 60 * 1000; } // 12 hours
            static get MAX_RESULTS() { return 5; }
            static get MAX_AUTHORS() { return 3; }
            
            static cache = new Map();

            static async search(query) {
                try {
                    const cachedResult = this.getFromCache(query);
                    if (cachedResult) return cachedResult;

                    // Search books and authors
                    const [books, authors] = await Promise.all([
                        this.searchBooks(query),
                        this.searchAuthors(query)
                    ]);

                    // Get detailed information
                    const enrichedResults = await this.enrichResults(books, authors);
                    
                    const formattedContent = this.formatResults(enrichedResults);
                    if (formattedContent) {
                        this.addToCache(query, formattedContent);
                    }

                    return formattedContent;
                } catch (error) {
                    console.error('Open Library search failed:', error);
                    return null;
                }
            }

            static async searchBooks(query) {
                try {
                    const params = new URLSearchParams({
                        q: query,
                        limit: this.MAX_RESULTS,
                        fields: 'key,title,author_name,first_publish_year,cover_i,edition_count,subject,isbn'
                    });

                    const response = await fetch(`${this.SEARCH_URL}?${params}`);
                    if (!response.ok) throw new Error(`Book search failed: ${response.status}`);

                    const data = await response.json();
                    return data.docs || [];
                } catch (error) {
                    console.error('Book search failed:', error);
                    return [];
                }
            }

            static async searchAuthors(query) {
                try {
                    const params = new URLSearchParams({
                        q: query,
                        type: '/type/author',
                        limit: this.MAX_AUTHORS
                    });

                    const response = await fetch(`${this.SEARCH_URL}?${params}`);
                    if (!response.ok) throw new Error(`Author search failed: ${response.status}`);

                    const data = await response.json();
                    return data.docs || [];
                } catch (error) {
                    console.error('Author search failed:', error);
                    return [];
                }
            }

            static async enrichResults(books, authors) {
                const enriched = {
                    books: await this.enrichBooks(books),
                    authors: await this.enrichAuthors(authors)
                };

                // Add recommendations based on subjects
                enriched.recommendations = this.getRecommendations(books);

                return enriched;
            }

            static async enrichBooks(books) {
                return Promise.all(books.map(async book => {
                    try {
                        const details = await this.fetchBookDetails(book.key);
                        return {
                            ...book,
                            ...details,
                            type: 'book'
                        };
                    } catch (error) {
                        console.error(`Failed to enrich book ${book.key}:`, error);
                        return { ...book, type: 'book' };
                    }
                }));
            }

            static async enrichAuthors(authors) {
                return Promise.all(authors.map(async author => {
                    try {
                        const details = await this.fetchAuthorDetails(author.key);
                        return {
                            ...author,
                            ...details,
                            type: 'author'
                        };
                    } catch (error) {
                        console.error(`Failed to enrich author ${author.key}:`, error);
                        return { ...author, type: 'author' };
                    }
                }));
            }

            static async fetchBookDetails(key) {
                try {
                    const response = await fetch(`${this.BASE_URL}/books${key}.json`);
                    if (!response.ok) return {};

                    const data = await response.json();
                    return {
                        description: data.description?.value || data.description,
                        subjects: data.subjects,
                        covers: data.covers,
                        excerpts: data.excerpts
                    };
                } catch (error) {
                    console.error(`Failed to fetch book details for ${key}:`, error);
                    return {};
                }
            }

            static async fetchAuthorDetails(key) {
                try {
                    const response = await fetch(`${this.BASE_URL}/authors${key}.json`);
                    if (!response.ok) return {};

                    const data = await response.json();
                    return {
                        bio: data.bio?.value || data.bio,
                        birth_date: data.birth_date,
                        death_date: data.death_date,
                        wikipedia: data.wikipedia
                    };
                } catch (error) {
                    console.error(`Failed to fetch author details for ${key}:`, error);
                    return {};
                }
            }

            static getRecommendations(books) {
                const subjects = new Map();
                
                // Count subject occurrences
                books.forEach(book => {
                    if (book.subject) {
                        book.subject.forEach(subject => {
                            const count = subjects.get(subject) || 0;
                            subjects.set(subject, count + 1);
                        });
                    }
                });

                // Get top subjects
                return Array.from(subjects.entries())
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 5)
                    .map(([subject]) => subject);
            }

            static formatResults(results) {
                const parts = [];

                // Add books section
                if (results.books.length) {
                    parts.push(
                        'ðŸ“š Books Found:',
                        ...results.books.map(book => this.formatBook(book))
                    );
                }

                // Add authors section
                if (results.authors.length) {
                    parts.push(
                        '\nðŸ‘¤ Authors:',
                        ...results.authors.map(author => this.formatAuthor(author))
                    );
                }

                // Add recommendations
                if (results.recommendations?.length) {
                    parts.push(
                        '\nðŸ“– Related Subjects:',
                        results.recommendations.map(subject => `â€¢ ${subject}`).join('\n')
                    );
                }

                return parts.length ? parts.join('\n\n') : null;
            }

            static formatBook(book) {
                const parts = [
                    `ðŸ“– ${book.title}`,
                    book.author_name ? `âœï¸ By: ${book.author_name.join(', ')}` : null,
                    book.first_publish_year ? `ðŸ“… First Published: ${book.first_publish_year}` : null,
                    book.edition_count ? `ðŸ“š Editions: ${book.edition_count}` : null,
                    book.description ? `\nðŸ“ Description:\n${this.truncateText(book.description, 300)}` : null,
                    book.subjects?.length ? `\nðŸ·ï¸ Subjects: ${book.subjects.slice(0, 5).join(', ')}` : null,
                    book.isbn ? `ðŸ“‡ ISBN: ${book.isbn[0]}` : null,
                    book.cover_i ? `ðŸ–¼ï¸ Cover: https://covers.openlibrary.org/b/id/${book.cover_i}-L.jpg` : null
                ];

                return parts.filter(Boolean).join('\n');
            }

            static formatAuthor(author) {
                const parts = [
                    `âœï¸ ${author.name}`,
                    author.birth_date ? `ðŸŽ‚ Born: ${author.birth_date}` : null,
                    author.death_date ? `â€  Died: ${author.death_date}` : null,
                    author.bio ? `\nðŸ“ Biography:\n${this.truncateText(author.bio, 300)}` : null,
                    author.wikipedia ? `ðŸ”— Wikipedia: ${author.wikipedia}` : null
                ];

                return parts.filter(Boolean).join('\n');
            }

            static truncateText(text, maxLength) {
                if (!text) return '';
                text = typeof text === 'string' ? text : text.toString();
                return text.length > maxLength ? text.substring(0, maxLength) + '...' : text;
            }

            // Cache methods remain the same as other services...
            static getFromCache(query) {
                const cached = this.cache.get(query);
                if (cached && Date.now() - cached.timestamp < this.CACHE_DURATION) {
                    return cached.data;
                }
                return null;
            }

            static addToCache(query, data) {
                this.cache.set(query, {
                    data,
                    timestamp: Date.now()
                });

                if (this.cache.size > 100) {
                    const oldestKey = Array.from(this.cache.entries())
                        .sort(([, a], [, b]) => a.timestamp - b.timestamp)[0][0];
                    this.cache.delete(oldestKey);
                }
            }
        }

        // Add this with other service implementations
        class GutenbergService {
            static get BASE_URL() { return 'https://gutendex.com'; }
            static get CACHE_DURATION() { return 24 * 60 * 60 * 1000; } // 24 hours
            static get MAX_RESULTS() { return 5; }
            static get MAX_SUBJECTS() { return 5; }
            
            static cache = new Map();

            static async search(query) {
                try {
                    const cachedResult = this.getFromCache(query);
                    if (cachedResult) return cachedResult;

                    // Search books and get details
                    const books = await this.searchBooks(query);
                    if (!books?.length) return null;

                    // Get additional information
                    const enrichedResults = await this.enrichResults(books);
                    
                    const formattedContent = this.formatResults(enrichedResults);
                    if (formattedContent) {
                        this.addToCache(query, formattedContent);
                    }

                    return formattedContent;
                } catch (error) {
                    console.error('Project Gutenberg search failed:', error);
                    return null;
                }
            }

            static async searchBooks(query) {
                try {
                    const params = new URLSearchParams({
                        search: query,
                        languages: 'en',
                        mime_type: 'text'
                    });

                    const response = await fetch(`${this.BASE_URL}/books?${params}`);
                    if (!response.ok) throw new Error(`Book search failed: ${response.status}`);

                    const data = await response.json();
                    return data.results?.slice(0, this.MAX_RESULTS) || [];
                } catch (error) {
                    console.error('Book search failed:', error);
                    return [];
                }
            }

            static async enrichResults(books) {
                const enriched = await Promise.all(books.map(async book => {
                    try {
                        // Get additional book information
                        const [subjects, downloads] = await Promise.all([
                            this.fetchSubjects(book.id),
                            this.fetchDownloadCount(book.id)
                        ]);

                        return {
                            ...book,
                            subjects,
                            downloads,
                            recommendations: await this.getRelatedBooks(book.subjects)
                        };
                    } catch (error) {
                        console.error(`Failed to enrich book ${book.id}:`, error);
                        return book;
                    }
                }));

                // Add overall recommendations
                return {
                    books: enriched,
                    topSubjects: this.getTopSubjects(enriched)
                };
            }

            static async fetchSubjects(bookId) {
                try {
                    const response = await fetch(`${this.BASE_URL}/books/${bookId}`);
                    if (!response.ok) return [];

                    const data = await response.json();
                    return data.subjects || [];
                } catch (error) {
                    console.error(`Failed to fetch subjects for book ${bookId}:`, error);
                    return [];
                }
            }

            static async fetchDownloadCount(bookId) {
                try {
                    const response = await fetch(`${this.BASE_URL}/books/${bookId}`);
                    if (!response.ok) return 0;

                    const data = await response.json();
                    return data.download_count || 0;
                } catch (error) {
                    console.error(`Failed to fetch download count for book ${bookId}:`, error);
                    return 0;
                }
            }

            static async getRelatedBooks(subjects) {
                if (!subjects?.length) return [];

                try {
                    const params = new URLSearchParams({
                        topic: subjects[0],
                        languages: 'en',
                        mime_type: 'text'
                    });

                    const response = await fetch(`${this.BASE_URL}/books?${params}`);
                    if (!response.ok) return [];

                    const data = await response.json();
                    return data.results
                        ?.filter(book => book.id !== bookId)
                        .slice(0, 3) || [];
                } catch (error) {
                    console.error('Failed to fetch related books:', error);
                    return [];
                }
            }

            static getTopSubjects(books) {
                const subjects = new Map();
                
                books.forEach(book => {
                    book.subjects?.forEach(subject => {
                        const count = subjects.get(subject) || 0;
                        subjects.set(subject, count + 1);
                    });
                });

                return Array.from(subjects.entries())
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, this.MAX_SUBJECTS)
                    .map(([subject]) => subject);
            }

            static formatResults(results) {
                const parts = [];

                // Add books section
                if (results.books.length) {
                    parts.push(
                        'ðŸ“š Classic Books Found:',
                        ...results.books.map(book => this.formatBook(book))
                    );
                }

                // Add top subjects
                if (results.topSubjects?.length) {
                    parts.push(
                        '\nðŸ“‘ Popular Subjects:',
                        results.topSubjects.map(subject => `â€¢ ${subject}`).join('\n')
                    );
                }

                return parts.length ? parts.join('\n\n') : null;
            }

            static formatBook(book) {
                const parts = [
                    `ðŸ“– ${book.title}`,
                    book.authors?.length ? `âœï¸ By: ${book.authors.map(a => a.name).join(', ')}` : null,
                    book.subjects?.length ? `ðŸ·ï¸ Subjects: ${book.subjects.slice(0, 5).join(', ')}` : null,
                    book.downloads ? `ðŸ“Š Downloads: ${book.downloads.toLocaleString()}` : null,
                    '',
                    'ðŸ“¥ Download Links:',
                    ...Object.entries(book.formats)
                        .filter(([format]) => format.includes('text'))
                        .map(([format, url]) => `â€¢ ${this.formatLinkType(format)}: ${url}`),
                    '',
                    book.recommendations?.length ? [
                        'ðŸ“š Related Books:',
                        ...book.recommendations.map(rec => `â€¢ ${rec.title} by ${rec.authors?.[0]?.name || 'Unknown'}`)
                    ].join('\n') : null
                ];

                return parts.filter(Boolean).join('\n');
            }

            static formatLinkType(format) {
                const types = {
                    'text/html': 'HTML',
                    'text/plain': 'Plain Text',
                    'application/epub+zip': 'EPUB',
                    'application/x-mobipocket-ebook': 'Kindle'
                };
                return types[format] || format;
            }

            // Cache methods remain the same as other services...
            static getFromCache(query) {
                const cached = this.cache.get(query);
                if (cached && Date.now() - cached.timestamp < this.CACHE_DURATION) {
                    return cached.data;
                }
                return null;
            }

            static addToCache(query, data) {
                this.cache.set(query, {
                    data,
                    timestamp: Date.now()
                });

                if (this.cache.size > 100) {
                    const oldestKey = Array.from(this.cache.entries())
                        .sort(([, a], [, b]) => a.timestamp - b.timestamp)[0][0];
                    this.cache.delete(oldestKey);
                }
            }
        }

        // Add this with other service implementations
        class GlobalDataService {
            static get CACHE_DURATION() { return 24 * 60 * 60 * 1000; } // 24 hours
            static get MAX_RESULTS() { return 5; }
            
            // API Endpoints
            static get ENDPOINTS() {
                return {
                    WORLD_BANK: 'https://api.worldbank.org/v2',
                    EUROSTAT: 'https://ec.europa.eu/eurostat/api/dissemination/statistics/1.0',
                    UN_DATA: 'https://data.un.org/ws',
                    ODN: 'https://api.opendatanetwork.com/v1',
                    DATA_USA: 'https://datausa.io/api'
                };
            }
            
            static cache = new Map();

            static async search(query) {
                try {
                    const cachedResult = this.getFromCache(query);
                    if (cachedResult) return cachedResult;

                    // Search across all data sources in parallel
                    const results = await this.searchAllSources(query);
                    if (!Object.values(results).some(r => r?.length)) return null;

                    const formattedContent = this.formatResults(results);
                    if (formattedContent) {
                        this.addToCache(query, formattedContent);
                    }

                    return formattedContent;
                } catch (error) {
                    console.error('Global data search failed:', error);
                    return null;
                }
            }

            static async searchAllSources(query) {
                const [worldBank, eurostat, unData, odn, dataUsa] = await Promise.all([
                    this.searchWorldBank(query),
                    this.searchEurostat(query),
                    this.searchUNData(query),
                    this.searchODN(query),
                    this.searchDataUSA(query)
                ]);

                return {
                    worldBank,
                    eurostat,
                    unData,
                    odn,
                    dataUsa
                };
            }

            static async searchWorldBank(query) {
                try {
                    const response = await fetch(
                        `${this.ENDPOINTS.WORLD_BANK}/indicator?format=json&per_page=${this.MAX_RESULTS}&q=${encodeURIComponent(query)}`
                    );
                    
                    if (!response.ok) return [];
                    const [metadata, data] = await response.json();
                    
                    if (!data?.length) return [];

                    // Get latest values for indicators
                    const enrichedData = await Promise.all(
                        data.map(async indicator => {
                            const values = await this.getWorldBankValues(indicator.id);
                            return { ...indicator, values };
                        })
                    );

                    return enrichedData;
                } catch (error) {
                    console.error('World Bank search failed:', error);
                    return [];
                }
            }

            static async getWorldBankValues(indicatorId) {
                try {
                    const response = await fetch(
                        `${this.ENDPOINTS.WORLD_BANK}/countries/all/indicators/${indicatorId}?format=json&per_page=5&sort=desc`
                    );
                    
                    if (!response.ok) return [];
                    const [metadata, data] = await response.json();
                    return data || [];
                } catch (error) {
                    console.error(`Failed to fetch World Bank values for ${indicatorId}:`, error);
                    return [];
                }
            }

            static async searchEurostat(query) {
                try {
                    const response = await fetch(
                        `${this.ENDPOINTS.EUROSTAT}/data/${encodeURIComponent(query)}`,
                        { headers: { 'Accept': 'application/json' } }
                    );
                    
                    if (!response.ok) return [];
                    const data = await response.json();
                    return data.value?.slice(0, this.MAX_RESULTS) || [];
                } catch (error) {
                    console.error('Eurostat search failed:', error);
                    return [];
                }
            }

            static async searchUNData(query) {
                try {
                    const response = await fetch(
                        `${this.ENDPOINTS.UN_DATA}/data.json?q=${encodeURIComponent(query)}&rows=${this.MAX_RESULTS}`
                    );
                    
                    if (!response.ok) return [];
                    const data = await response.json();
                    return data.data || [];
                } catch (error) {
                    console.error('UN Data search failed:', error);
                    return [];
                }
            }

            static async searchODN(query) {
                try {
                    const response = await fetch(
                        `${this.ENDPOINTS.ODN}/data/v1/question?q=${encodeURIComponent(query)}&limit=${this.MAX_RESULTS}`
                    );
                    
                    if (!response.ok) return [];
                    const data = await response.json();
                    return data.results || [];
                } catch (error) {
                    console.error('Open Data Network search failed:', error);
                    return [];
                }
            }

            static async searchDataUSA(query) {
                try {
                    const response = await fetch(
                        `${this.ENDPOINTS.DATA_USA}/search/?q=${encodeURIComponent(query)}&limit=${this.MAX_RESULTS}`
                    );
                    
                    if (!response.ok) return [];
                    const data = await response.json();
                    return data.data || [];
                } catch (error) {
                    console.error('Data USA search failed:', error);
                    return [];
                }
            }

            static formatResults(results) {
                const sections = [];

                // World Bank Section
                if (results.worldBank?.length) {
                    sections.push(
                        'ðŸŒ World Bank Indicators:',
                        ...results.worldBank.map(indicator => this.formatWorldBankIndicator(indicator))
                    );
                }

                // Eurostat Section
                if (results.eurostat?.length) {
                    sections.push(
                        '\nðŸ“Š European Statistics:',
                        ...results.eurostat.map(stat => this.formatEurostatData(stat))
                    );
                }

                // UN Data Section
                if (results.unData?.length) {
                    sections.push(
                        '\nðŸ‡ºðŸ‡³ United Nations Data:',
                        ...results.unData.map(data => this.formatUNData(data))
                    );
                }

                // Open Data Network Section
                if (results.odn?.length) {
                    sections.push(
                        '\nðŸ” Open Data Network:',
                        ...results.odn.map(data => this.formatODNData(data))
                    );
                }

                // Data USA Section
                if (results.dataUsa?.length) {
                    sections.push(
                        '\nðŸ‡ºðŸ‡¸ Data USA:',
                        ...results.dataUsa.map(data => this.formatDataUSA(data))
                    );
                }

                return sections.length ? sections.join('\n\n') : null;
            }

            static formatWorldBankIndicator(indicator) {
                const parts = [
                    `ðŸ“ˆ ${indicator.name}`,
                    `ðŸ” ${indicator.sourceNote || 'No description available'}`,
                    '',
                    'ðŸ“Š Latest Values:'
                ];

                if (indicator.values?.length) {
                    parts.push(...indicator.values.map(value => 
                        `â€¢ ${value.country.value}: ${value.value} (${value.date})`
                    ));
                }

                return parts.join('\n');
            }

            static formatEurostatData(stat) {
                return [
                    `ðŸ“Š ${stat.title || 'Untitled Dataset'}`,
                    stat.description ? `ðŸ“ ${stat.description}` : null,
                    stat.value ? `ðŸ“ˆ Value: ${stat.value}` : null,
                    stat.time ? `â° Time: ${stat.time}` : null
                ].filter(Boolean).join('\n');
            }

            static formatUNData(data) {
                return [
                    `ðŸ“Š ${data.title || 'Untitled Dataset'}`,
                    data.description ? `ðŸ“ ${data.description}` : null,
                    data.value ? `ðŸ“ˆ Value: ${data.value}` : null,
                    data.year ? `ðŸ“… Year: ${data.year}` : null,
                    data.source ? `ðŸ“š Source: ${data.source}` : null
                ].filter(Boolean).join('\n');
            }

            static formatODNData(data) {
                return [
                    `ðŸ“Š ${data.title || 'Untitled Dataset'}`,
                    data.description ? `ðŸ“ ${data.description}` : null,
                    data.value ? `ðŸ“ˆ Value: ${data.value}` : null,
                    data.region ? `ðŸŒ Region: ${data.region}` : null,
                    data.source ? `ðŸ“š Source: ${data.source}` : null
                ].filter(Boolean).join('\n');
            }

            static formatDataUSA(data) {
                return [
                    `ðŸ“Š ${data.title || 'Untitled Dataset'}`,
                    data.description ? `ðŸ“ ${data.description}` : null,
                    data.value ? `ðŸ“ˆ Value: ${data.value}` : null,
                    data.year ? `ðŸ“… Year: ${data.year}` : null,
                    data.source ? `ðŸ“š Source: ${data.source}` : null
                ].filter(Boolean).join('\n');
            }

            // Cache methods remain the same...
            static getFromCache(query) {
                const cached = this.cache.get(query);
                if (cached && Date.now() - cached.timestamp < this.CACHE_DURATION) {
                    return cached.data;
                }
                return null;
            }

            static addToCache(query, data) {
                this.cache.set(query, {
                    data,
                    timestamp: Date.now()
                });

                if (this.cache.size > 100) {
                    const oldestKey = Array.from(this.cache.entries())
                        .sort(([, a], [, b]) => a.timestamp - b.timestamp)[0][0];
                    this.cache.delete(oldestKey);
                }
            }
        }

        // Add this with other service implementations
        class InfoAggregatorService {
            // Configuration
            static get CONFIG() {
                return {
                    CACHE_TIME: 6 * 60 * 60 * 1000, // 6 hours
                    MAX_RESULTS: 5,
                    ENDPOINTS: {
                        NEWS: {
                            URL: 'https://newsapi.org/v2',
                            KEY: 'YOUR_NEWS_API_KEY'
                        },
                        MEDIA: {
                            URL: 'http://api.mediastack.com/v1',
                            KEY: 'YOUR_MEDIASTACK_KEY'
                        },
                        ARCHIVE: {
                            URL: 'https://archive.org/advancedsearch.php'
                        }
                    }
                };
            }
            
            static cache = new Map();

            // Main search method
            static async search(query) {
                try {
                    // Check cache
                    const cached = this.getFromCache(query);
                    if (cached) return cached;

                    // Get results from all sources
                    const results = await this.fetchAllSources(query);
                    
                    // Format and cache results
                    const formatted = this.formatResults(results);
                    if (formatted) {
                        this.addToCache(query, formatted);
                    }

                    return formatted;
                } catch (error) {
                    console.error('InfoAggregator search failed:', error);
                    return null;
                }
            }

            // Source-specific search methods
            static async fetchAllSources(query) {
                const [news, media, archives] = await Promise.all([
                    this.fetchNews(query),
                    this.fetchMedia(query),
                    this.fetchArchives(query)
                ]);

                return { news, media, archives };
            }

            static async fetchNews(query) {
                const params = {
                    q: query,
                    language: 'en',
                    pageSize: this.CONFIG.MAX_RESULTS
                };

                return this.makeRequest(
                    `${this.CONFIG.ENDPOINTS.NEWS.URL}/everything`,
                    params,
                    { 'X-Api-Key': this.CONFIG.ENDPOINTS.NEWS.KEY }
                );
            }

            static async fetchMedia(query) {
                const params = {
                    keywords: query,
                    languages: 'en',
                    limit: this.CONFIG.MAX_RESULTS
                };

                return this.makeRequest(
                    `${this.CONFIG.ENDPOINTS.MEDIA.URL}/news`,
                    { ...params, access_key: this.CONFIG.ENDPOINTS.MEDIA.KEY }
                );
            }

            static async fetchArchives(query) {
                const params = {
                    q: query,
                    rows: this.CONFIG.MAX_RESULTS,
                    output: 'json',
                    'fl[]': ['identifier', 'title', 'description', 'year', 'mediatype', 'creator']
                };

                return this.makeRequest(this.CONFIG.ENDPOINTS.ARCHIVE.URL, params);
            }

            // Helper methods
            static async makeRequest(url, params, headers = {}) {
                try {
                    const response = await fetch(`${url}?${new URLSearchParams(params)}`, { headers });
                    if (!response.ok) throw new Error(`Request failed: ${response.status}`);
                    const data = await response.json();
                    return data?.articles || data?.data || data?.response?.docs || [];
                } catch (error) {
                    console.error(`Request failed for ${url}:`, error);
                    return [];
                }
            }

            // Formatting methods
            static formatResults(results) {
                const sections = [];

                // News section
                if (results.news.length) {
                    sections.push(
                        'ðŸ“° Latest News',
                        ...results.news.map(item => this.formatNewsItem(item))
                    );
                }

                // Media section
                if (results.media.length) {
                    sections.push(
                        '\nðŸ“± Media Coverage',
                        ...results.media.map(item => this.formatMediaItem(item))
                    );
                }

                // Archives section
                if (results.archives.length) {
                    sections.push(
                        '\nðŸ“š Historical Archives',
                        ...results.archives.map(item => this.formatArchiveItem(item))
                    );
                }

                return sections.length ? sections.join('\n\n') : null;
            }

            static formatNewsItem(item) {
                return [
                    `ðŸ“„ ${item.title}`,
                    item.description && `ðŸ“ ${item.description}`,
                    item.author && `âœï¸ By: ${item.author}`,
                    item.source?.name && `ðŸ“° Source: ${item.source.name}`,
                    item.url && `ðŸ”— Link: ${item.url}`
                ].filter(Boolean).join('\n');
            }

            static formatMediaItem(item) {
                return [
                    `ðŸ“„ ${item.title}`,
                    item.description && `ðŸ“ ${item.description}`,
                    item.category && `ðŸ·ï¸ Category: ${item.category}`,
                    item.source && `ðŸ“° Source: ${item.source}`,
                    item.url && `ðŸ”— Link: ${item.url}`
                ].filter(Boolean).join('\n');
            }

            static formatArchiveItem(item) {
                return [
                    `ðŸ“š ${item.title}`,
                    item.description && `ðŸ“ ${item.description}`,
                    item.creator && `ðŸ‘¤ Creator: ${item.creator}`,
                    item.year && `ðŸ“… Year: ${item.year}`,
                    `ðŸ”— Link: https://archive.org/details/${item.identifier}`
                ].filter(Boolean).join('\n');
            }

            // Cache methods
            static getFromCache(query) {
                const cached = this.cache.get(query);
                if (cached?.timestamp > Date.now() - this.CONFIG.CACHE_TIME) {
                    return cached.data;
                }
                return null;
            }

            static addToCache(query, data) {
                this.cache.set(query, {
                    data,
                    timestamp: Date.now()
                });

                // Clean old cache entries
                if (this.cache.size > 100) {
                    const oldestKey = Array.from(this.cache.entries())
                        .sort(([, a], [, b]) => a.timestamp - b.timestamp)[0][0];
                    this.cache.delete(oldestKey);
                }
            }
        }

        // KnowledgeAggregator implementation
        class KnowledgeAggregator {
            // Static configuration for API sources
            static get API_CONFIG() {
                return {
                    Wikipedia: { type: 'encyclopedia' },
                    DuckDuckGo: { type: 'web' },
                    Reddit: { type: 'social' },
                    Wikidata: { type: 'structured' },
                    arXiv: { type: 'academic' },
                    Unpaywall: { type: 'academic' },
                    Crossref: { type: 'academic' },
                    CORE: { type: 'academic' },
                    OpenCitations: { type: 'academic' },
                    PublicAPIs: { type: 'technical' },
                    GitHub: { type: 'code' },
                    StackExchange: { type: 'technical' },
                    RapidAPI: { type: 'technical' },
                    Postman: { type: 'technical' },
                    DBpedia: { type: 'structured' },
                    OpenLibrary: { type: 'books' },
                    Gutenberg: { type: 'books' },
                    GlobalData: { type: 'data' },
                    InfoAggregator: { type: 'news' }
                };
            }

            static async getKnowledge(query) {
                try {
                    const results = await Promise.allSettled([
                        WikipediaService.search(query),
                        DuckDuckGoService.search(query),
                        RedditService.search(query),
                        WikidataService.search(query),
                        ArXivService.search(query),
                        UnpaywallService.search(query),
                        CrossrefService.search(query),
                        CoreService.search(query),
                        OpenCitationsService.search(query),
                        PublicApisService.search(query),
                        GitHubService.search(query),
                        StackExchangeService.search(query),
                        RapidApiService.search(query),
                        PostmanService.search(query),
                        DBpediaService.search(query),
                        OpenLibraryService.search(query),
                        GutenbergService.search(query),
                        GlobalDataService.search(query),
                        InfoAggregatorService.search(query)
                    ]);

                    const sources = new Map();
                    const apiConfig = this.API_CONFIG;
                    const apiNames = Object.keys(apiConfig);

                    results.forEach((result, index) => {
                        if (result.status === 'fulfilled' && result.value) {
                            const apiName = apiNames[index];
                            sources.set(apiNames[index], {
                                type: apiConfig[apiName].type,
                                content: result.value,
                                score: this.calculateRelevanceScore(result.value, query)
                            });
                        }
                    });

                    if (sources.size === 0) {
                        return "I couldn't find any relevant information about that.";
                    }

                    return this.formatResponses(sources, query);
                } catch (error) {
                    console.error('Knowledge aggregation failed:', error);
                    return "I'm having trouble accessing my knowledge sources right now.";
                }
            }

            static calculateRelevanceScore(content, query) {
                if (!content) return 0;
                
                // Basic relevance scoring
                const queryTerms = query.toLowerCase().split(' ');
                const contentLower = content.toLowerCase();
                
                let score = 0;
                // Term frequency
                queryTerms.forEach(term => {
                    const count = (contentLower.match(new RegExp(term, 'g')) || []).length;
                    score += count;
                });
                
                // Length penalty (prefer concise responses)
                score = score / Math.log(content.length);
                
                // Bonus for academic and structured content
                if (content.includes('doi.org') || content.includes('arxiv.org')) score *= 1.2;
                if (content.includes('Abstract') || content.includes('Introduction')) score *= 1.1;
                
                return score;
            }

            static formatResponses(sources, query) {
                // Sort sources by relevance score
                const sortedSources = Array.from(sources.entries())
                    .sort((a, b) => b[1].score - a[1].score);

                // Get top 2 most relevant responses
                const topResponses = sortedSources.slice(0, 2);
                const remainingSources = sortedSources.slice(2);

                // Create main container
                const container = document.createElement('div');
                container.className = 'responses-container';

                // Create responses box
                const responsesBox = document.createElement('div');
                responsesBox.className = 'responses-box';

                // Add top responses
                topResponses.forEach((source, index) => {
                    const responseDiv = document.createElement('div');
                    responseDiv.className = 'response-item';
                    responseDiv.innerHTML = `
                        <div class="response-header">Response ${index + 1}</div>
                        <div class="response-content">${source[1].content}</div>
                    `;
                    responsesBox.appendChild(responseDiv);
                });

                container.appendChild(responsesBox);

                // Add view more option if there are additional sources
                if (remainingSources.length > 0) {
                    const hiddenData = document.createElement('div');
                    hiddenData.style.display = 'none';
                    hiddenData.id = `sources-${Date.now()}`;
                    hiddenData.dataset.sources = JSON.stringify(remainingSources);
                    container.appendChild(hiddenData);

                    // Add view all button
                    const viewAllButton = document.createElement('button');
                    viewAllButton.className = 'view-all-btn';
                    viewAllButton.innerHTML = `
                        <span>View ${remainingSources.length} More Sources</span>
                        <i data-lucide="chevron-down" class="w-4 h-4"></i>
                    `;
                    viewAllButton.onclick = () => this.showAllSources(hiddenData.id);
                    container.appendChild(viewAllButton);
                    
                    // Refresh Lucide icons
                    lucide.createIcons();
                }

                return container;
            }

            static showAllSources(dataId) {
                const hiddenData = document.getElementById(dataId);
                if (!hiddenData) return;

                const sources = JSON.parse(hiddenData.dataset.sources);
                // Create modal for additional sources
                const modal = document.createElement('div');
                modal.className = 'fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4';
                
                let sourcesContent = sources.map((source, index) => `
                    <div class="response-item mb-4">
                        <div class="response-header bg-dark-400 p-2 rounded-t-lg">
                            Response ${index + 3}
                        </div>
                        <div class="response-content bg-dark-300 p-4 rounded-b-lg">
                            ${source[1].content}
                        </div>
                    </div>
                `).join('');

                modal.innerHTML = `
                    <div class="bg-dark-200 rounded-lg max-w-4xl w-full max-h-[80vh] overflow-y-auto p-6 relative">
                        <button onclick="this.closest('.fixed').remove()" 
                                class="absolute top-4 right-4 text-gray-400 hover:text-white">
                            <i data-lucide="x" class="w-5 h-5"></i>
                        </button>
                        <h2 class="text-2xl font-bold text-accent-blue mb-6">Additional Sources</h2>
                        <div class="space-y-4">
                            ${sourcesContent}
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                lucide.createIcons();

                // Remove the button and hidden data
                const button = document.querySelector('.view-all-btn');
                if (button) button.remove();
                hiddenData.remove();
            }
        }

        // Chat functionality
        class Chat {
            constructor() {
                this.chatContainer = document.querySelector('.chat-container');
                this.messageInput = document.querySelector('#message-input');
                this.sendButton = document.querySelector('#send-button');
                
                this.setupEventListeners();
            }

            setupEventListeners() {
                this.sendButton.addEventListener('click', () => this.handleSend());
                this.messageInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.handleSend();
                    }
                });
            }

            async handleSend() {
                const message = this.messageInput.value.trim();
                if (!message) return;

                // Clear input
                this.messageInput.value = '';

                // Add user message
                this.addMessage(message, 'user');

                // Show typing indicator
                this.showTypingIndicator();

                try {
                    // Get response from KnowledgeAggregator
                    const response = await this.getKnowledge(message);
                    
                    // Remove typing indicator and add response
                    this.removeTypingIndicator();
                    this.addMessage(response, 'assistant');
                } catch (error) {
                    console.error('Failed to get response:', error);
                    this.removeTypingIndicator();
                    this.addMessage("I'm sorry, I encountered an error while processing your request.", 'assistant');
                }
            }

            async getKnowledge(query) {
                try {
                    this.updateTypingIndicator('Searching knowledge sources...');
                    const response = await KnowledgeAggregator.getKnowledge(query);
                    
                    if (!response) {
                        return "I couldn't find specific information about that. Please try rephrasing your question.";
                    }

                    return response;
                } catch (error) {
                    console.error('Knowledge aggregation failed:', error);
                    return "I apologize, but I'm having trouble accessing my knowledge sources. Please try again in a moment.";
                }
            }

            updateTypingIndicator(message) {
                const indicator = document.getElementById('typing-indicator');
                if (indicator) {
                    const messageSpan = indicator.querySelector('.typing-message');
                    if (messageSpan) {
                        messageSpan.textContent = message;
                    } else {
                        const span = document.createElement('span');
                        span.className = 'typing-message text-sm text-gray-400 ml-2';
                        span.textContent = message;
                        indicator.appendChild(span);
                    }
                }
            }

            showTypingIndicator() {
                const indicator = document.createElement('div');
                indicator.className = 'typing-indicator flex items-center';
                indicator.id = 'typing-indicator';
                indicator.innerHTML = `
                    <div class="flex space-x-1">
                        <span></span>
                        <span></span>
                        <span></span>
                    </div>
                    <span class="typing-message text-sm text-gray-400 ml-2">Thinking...</span>
                `;
                this.chatContainer.appendChild(indicator);
                this.scrollToBottom();
            }

            // Add CSS for better typing indicator
            static addStyles() {
                const style = document.createElement('style');
                style.textContent = `
                    .typing-indicator {
                        background-color: #1e2235;
                        padding: 12px 16px;
                        border-radius: 12px;
                        margin: 8px 0;
                        display: flex;
                        align-items: center;
                    }

                    .typing-indicator span {
                        display: inline-block;
                        width: 8px;
                        height: 8px;
                        background-color: #60a5fa;
                        border-radius: 50%;
                        margin: 0 2px;
                        animation: bounce 1.4s infinite ease-in-out;
                    }

                    .typing-indicator span:nth-child(1) { animation-delay: 0s; }
                    .typing-indicator span:nth-child(2) { animation-delay: 0.2s; }
                    .typing-indicator span:nth-child(3) { animation-delay: 0.4s; }

                    @keyframes bounce {
                        0%, 80%, 100% { transform: translateY(0); }
                        40% { transform: translateY(-8px); }
                    }
                `;
                document.head.appendChild(style);
            }

            addMessage(content, type) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${type}-message`;
                
                // Check if content is an HTML element
                if (content instanceof HTMLElement) {
                    messageDiv.appendChild(content);
                } else {
                    messageDiv.textContent = content;
                }
                
                this.chatContainer.appendChild(messageDiv);
                this.scrollToBottom();
            }

            removeTypingIndicator() {
                const indicator = document.getElementById('typing-indicator');
                if (indicator) {
                    indicator.remove();
                }
            }

            scrollToBottom() {
                this.chatContainer.scrollTop = this.chatContainer.scrollHeight;
            }
        }

        // Initialize chat and styles when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            Chat.addStyles();
            const chat = new Chat();
            
            // Add welcome message
            chat.addMessage(`ðŸ‘‹ Welcome to FP-GPT!

I'm Dron Pancholi, the creator of this AI knowledge assistant. FP-GPT is designed to provide comprehensive answers by aggregating information from multiple reliable sources in real-time.

Feel free to:
â€¢ Ask any question
â€¢ Explore complex topics
â€¢ Get real-time information
â€¢ Access multiple knowledge sources including academic papers from arXiv

Try asking something like:
"What are the latest developments in quantum computing?"
"Show me recent research papers on machine learning"
or
"Explain the impact of AI on healthcare"
ALSO THE FP-GPT V0.1 OPEN SOURCE IS LIVE!!! CHECK IT OUT IN THE GITHUB REPOSITORY!! 

Let me know if you need any help! ðŸš€`, 'assistant');
            
            // Refresh Lucide icons after any dynamic content changes
            lucide.createIcons();
        });

        // Smooth scroll to top
        function scrollToTop() {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        }

        // Privacy Policy Modal
        function showPrivacyPolicy() {
            event.preventDefault();
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-50 p-4';
            modal.innerHTML = `
                <div class="bg-dark-200/95 backdrop-blur-sm rounded-lg max-w-2xl w-full max-h-[80vh] overflow-y-auto relative">
                    <div class="sticky top-0 bg-dark-200/95 backdrop-blur-sm p-6 border-b border-dark-400 flex items-center justify-between">
                        <h2 class="text-2xl font-bold text-gradient bg-gradient-to-r from-accent-blue to-accent-purple">Privacy Policy</h2>
                        <button onclick="this.closest('.fixed').remove()" 
                                class="p-2 hover:bg-dark-300 rounded-lg transition-colors">
                            <i data-lucide="x" class="w-5 h-5 text-gray-400"></i>
                        </button>
                    </div>
                    <div class="p-6 prose prose-invert prose-sm">
                        <p class="text-gray-400">Last updated: January 2025</p>
                        <h3 class="text-lg font-semibold text-white mt-6">Information We Collect</h3>
                        <ul class="text-gray-300 list-disc pl-5 space-y-2">
                            <li>Query content and search history</li>
                            <li>Usage patterns and interaction data</li>
                            <li>Technical information (browser type, device info)</li>
                            <li>Performance metrics and error logs</li>
                        </ul>

                        <h3 class="text-lg font-semibold text-white mt-6">How We Use Your Information</h3>
                        <ul class="text-gray-300 list-disc pl-5 space-y-2">
                            <li>Improve search results and relevance</li>
                            <li>Enhance user experience and interface</li>
                            <li>Debug and optimize performance</li>
                            <li>Develop new features and capabilities</li>
                        </ul>

                        <h3 class="text-lg font-semibold text-white mt-6">Data Security</h3>
                        <p class="text-gray-300">
                            We implement industry-standard security measures to protect your data:
                        </p>
                        <ul class="text-gray-300 list-disc pl-5 space-y-2">
                            <li>End-to-end encryption for all communications</li>
                            <li>Regular security audits and updates</li>
                            <li>Secure data storage and handling</li>
                            <li>Limited employee access to user data</li>
                        </ul>

                        <h3 class="text-lg font-semibold text-white mt-6">Your Rights</h3>
                        <p class="text-gray-300">
                            You have the right to:
                        </p>
                        <ul class="text-gray-300 list-disc pl-5 space-y-2">
                            <li>Access your personal data</li>
                            <li>Request data deletion</li>
                            <li>Opt-out of data collection</li>
                            <li>Export your data</li>
                        </ul>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            lucide.createIcons();
        }

        // Terms & Conditions Modal
        function showTerms() {
            event.preventDefault();
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-50 p-4';
            modal.innerHTML = `
                <div class="bg-dark-200/95 backdrop-blur-sm rounded-lg max-w-2xl w-full max-h-[80vh] overflow-y-auto relative">
                    <div class="sticky top-0 bg-dark-200/95 backdrop-blur-sm p-6 border-b border-dark-400 flex items-center justify-between">
                        <h2 class="text-2xl font-bold text-gradient bg-gradient-to-r from-accent-blue to-accent-purple">Terms & Conditions</h2>
                        <button onclick="this.closest('.fixed').remove()" 
                                class="p-2 hover:bg-dark-300 rounded-lg transition-colors">
                            <i data-lucide="x" class="w-5 h-5 text-gray-400"></i>
                        </button>
                    </div>
                    <div class="p-6 prose prose-invert prose-sm">
                        <p class="text-gray-400">Last updated: January 2025</p>
                        <h3 class="text-lg font-semibold text-white mt-6">1. Acceptance of Terms</h3>
                        <p class="text-gray-300">
                            By accessing or using FP-GPT, you agree to be bound by these terms and conditions, all applicable laws and regulations, and agree that you are responsible for compliance with any applicable local laws.
                        </p>
                        <h3 class="text-lg font-semibold text-white mt-6">2. Use License</h3>
                        <ul class="text-gray-300 list-disc pl-5 space-y-2">
                            <li>Personal, non-commercial use only</li>
                            <li>No reproduction without permission</li>
                            <li>No modification or derivative works</li>
                            <li>No unauthorized distribution</li>
                        </ul>

                        <h3 class="text-lg font-semibold text-white mt-6">3. Disclaimer</h3>
                        <p class="text-gray-300">
                            The materials on FP-GPT are provided on an 'as is' basis. We make no warranties, expressed or implied, and hereby disclaim and negate all other warranties including, without limitation, implied warranties or conditions of merchantability, fitness for a particular purpose, or non-infringement of intellectual property or other violation of rights.
                        </p>
                        <h3 class="text-lg font-semibold text-white mt-6">4. Limitations</h3>
                        <ul class="text-gray-300 list-disc pl-5 space-y-2">
                            <li>No guarantee of continuous service</li>
                            <li>Right to modify or discontinue service</li>
                            <li>No liability for data loss or damage</li>
                            <li>Usage limits may apply</li>
                        </ul>

                        <h3 class="text-lg font-semibold text-white mt-6">5. Governing Law</h3>
                        <p class="text-gray-300">
                            These terms and conditions are governed by and construed in accordance with the laws, and you irrevocably submit to the exclusive jurisdiction of the courts in that location.
                        </p>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            lucide.createIcons();
        }
    </script>

    <style>
        /* Custom styles */
        .chat-container {
            max-height: calc(100vh - 180px);
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: #565f89 #1a1b26;
        }

        .chat-container::-webkit-scrollbar {
            width: 8px;
        }

        .chat-container::-webkit-scrollbar-track {
            background: #1a1b26;
        }

        .chat-container::-webkit-scrollbar-thumb {
            background-color: #565f89;
            border-radius: 4px;
        }

        .message {
            max-width: 85%;
            margin: 8px 0;
            padding: 12px 16px;
            border-radius: 12px;
            font-size: 0.95rem;
            line-height: 1.5;
        }

        .user-message {
            background: linear-gradient(135deg, #60a5fa, #8b5cf6);
            color: white;
            margin-left: auto;
        }

        .assistant-message {
            background-color: #161926;
            color: #e2e8f0;
            margin-right: auto;
            white-space: pre-wrap;
            border: 1px solid #2a2f4440;
        }

        .source-tag {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            background-color: #414868;
            color: #c0caf5;
            margin-bottom: 4px;
        }

        .response-actions button {
            transition: all 0.2s;
            background-color: #414868;
            color: #c0caf5;
        }

        .response-actions button:hover {
            background-color: #565f89;
            transform: translateY(-1px);
        }

        .typing-indicator {
            display: inline-block;
            padding: 12px 24px;
            background-color: #24283b;
            border-radius: 12px;
            margin: 8px 0;
        }

        .typing-indicator span {
            display: inline-block;
            width: 8px;
            height: 8px;
            background-color: #7aa2f7;
            border-radius: 50%;
            margin: 0 2px;
            animation: bounce 1.4s infinite ease-in-out;
        }

        .gradient-text {
            background: linear-gradient(45deg, #60a5fa, #34d399, #8b5cf6);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            animation: gradient 8s linear infinite;
        }

        .gradient-border {
            position: relative;
            border: 1px solid transparent;
            background: linear-gradient(45deg, #60a5fa20, #34d39920, #8b5cf620);
            background-clip: padding-box;
        }

        .gradient-border::before {
            content: '';
            position: absolute;
            top: -1px;
            right: -1px;
            bottom: -1px;
            left: -1px;
            z-index: -1;
            border-radius: inherit;
            background: linear-gradient(45deg, #60a5fa, #34d399, #8b5cf6);
            opacity: 0.3;
        }

        @keyframes bounce {
            0%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-8px); }
        }

        .typing-indicator span:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-indicator span:nth-child(3) {
            animation-delay: 0.4s;
        }

        .response-container {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .view-all-btn {
            align-self: flex-start;
            cursor: pointer;
            font-weight: 500;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .view-all-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .responses-container {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            width: 100%;
        }

        .responses-box {
            background: #1e2235;
            border-radius: 12px;
            padding: 1rem;
            border: 1px solid #2a2f44;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .response-item {
            background: #161926;
            border-radius: 8px;
            overflow: hidden;
        }

        .response-header {
            background: #2a2f44;
            padding: 0.5rem 1rem;
            font-weight: 500;
            color: #60a5fa;
            font-size: 0.9rem;
        }

        .response-content {
            padding: 1rem;
            white-space: pre-wrap;
        }

        .additional-responses {
            margin-top: 1rem;
        }

        .view-all-btn {
            background: #60a5fa;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            align-self: flex-start;
            cursor: pointer;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: all 0.2s ease;
        }

        .view-all-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            background: #3b82f6;
        }

        /* Response items in modal */
        .response-item {
            border: 1px solid rgba(96, 165, 250, 0.1);
            border-radius: 0.5rem;
            overflow: hidden;
            transition: all 0.2s ease;
        }

        .response-item:hover {
            border-color: rgba(96, 165, 250, 0.2);
            transform: translateY(-1px);
        }

        .response-header {
            font-weight: 500;
            color: #60a5fa;
            font-size: 0.9rem;
        }

        .response-content {
            white-space: pre-wrap;
            color: #9ca3af;
            font-size: 0.875rem;
            line-height: 1.5;
        }

        /* Gradient text */
        .text-gradient {
            background-clip: text;
            -webkit-background-clip: text;
            color: transparent;
        }

        /* Counter animation */
        @keyframes countUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .counter {
            animation: countUp 1s ease-out forwards;
        }

        /* Stats hover effect */
        .stats-card {
            transition: all 0.3s ease;
        }

        .stats-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }

        /* Enhanced animations */
        @keyframes pulse-slow {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .animate-pulse-slow {
            animation: pulse-slow 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        
        .delay-100 {
            animation-delay: 0.1s;
        }
        
        .delay-200 {
            animation-delay: 0.2s;
        }

        /* Enhanced hover effects */
        .hover-glow:hover {
            box-shadow: 0 0 15px rgba(96, 165, 250, 0.3);
        }

        /* Blob animation */
        @keyframes blob {
            0% { transform: translate(0px, 0px) scale(1); }
            33% { transform: translate(30px, -50px) scale(1.1); }
            66% { transform: translate(-20px, 20px) scale(0.9); }
            100% { transform: translate(0px, 0px) scale(1); }
        }
        
        .animate-blob {
            animation: blob 7s infinite;
        }
        
        .animation-delay-2000 {
            animation-delay: 2s;
        }
        
        .animation-delay-4000 {
            animation-delay: 4s;
        }
        
        /* Float animation */
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-5px); }
            100% { transform: translateY(0px); }
        }
        
        .animate-float {
            animation: float 3s ease-in-out infinite;
        }
    </style>
</head>
<body class="bg-dark-100 text-gray-100 min-h-screen flex flex-col">
    <!-- Header -->
    <header class="relative overflow-hidden bg-dark-200 border-b border-dark-300">
        <!-- Animated Background Elements -->
        <div class="absolute inset-0">
            <div class="absolute top-0 left-0 w-full h-1 bg-gradient-to-r from-accent-blue via-accent-purple to-accent-green"></div>
            <div class="absolute inset-0 bg-grid-pattern opacity-5"></div>
        </div>

        <div class="relative max-w-7xl mx-auto px-4 py-8">
            <div class="flex flex-col md:flex-row items-center justify-between gap-6">
                <!-- Logo Section -->
                <div class="flex items-center gap-4">
                    <div class="relative group">
                        <div class="absolute -inset-2 bg-gradient-to-r from-accent-blue via-accent-purple to-accent-green opacity-25 group-hover:opacity-75 blur transition-all duration-500 rounded-full"></div>
                        <div class="relative">
                            <i data-lucide="brain-circuit" class="w-12 h-12 text-white transition-transform group-hover:scale-110"></i>
                            <div class="absolute -top-1 -right-1 w-3 h-3 bg-accent-green rounded-full animate-ping-slow"></div>
                        </div>
                    </div>
                    <div>
                        <h1 class="text-3xl font-bold tracking-wide text-gradient bg-gradient-to-r from-accent-blue via-accent-purple to-accent-green">
                            FP-GPT
                        </h1>
                        <div class="flex items-center gap-3 mt-1">
                            <span class="bg-dark-300/50 backdrop-blur-sm px-2 py-0.5 rounded-full text-xs border border-accent-blue/20">v0.3 tendi</span>
                            <a href="https://github.com/dronpancholi" target="_blank" 
                               class="group flex items-center gap-1.5 text-sm">
                                <span class="text-gray-400">by</span>
                                <span class="text-accent-blue group-hover:text-accent-purple transition-colors">Dron Pancholi</span>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Team Inspiration -->
                <div class="flex flex-col md:flex-row items-center gap-4">
                    <div class="group relative overflow-hidden rounded-xl bg-dark-300/30 backdrop-blur-sm border border-dark-400 p-3 hover:border-accent-blue/30 transition-all duration-300">
                        <div class="flex items-center gap-3">
                            <div class="p-2 rounded-lg bg-accent-blue/10 group-hover:bg-accent-blue/20 transition-colors">
                                <i data-lucide="trophy" class="w-5 h-5 text-accent-blue"></i>
                            </div>
                            <div>
                                <div class="text-sm font-medium text-gray-300">Royal Challengers</div>
                                <div class="text-xs text-accent-blue animate-pulse-slow">Ee Sala Cup Namde ðŸ</div>
                            </div>
                        </div>
                    </div>

                    <div class="group relative overflow-hidden rounded-xl bg-dark-300/30 backdrop-blur-sm border border-dark-400 p-3 hover:border-accent-purple/30 transition-all duration-300">
                        <div class="flex items-center gap-3">
                            <div class="p-2 rounded-lg bg-accent-purple/10 group-hover:bg-accent-purple/20 transition-colors">
                                <i data-lucide="car" class="w-5 h-5 text-accent-purple"></i>
                            </div>
                            <div>
                                <div class="text-sm font-medium text-gray-300">Oracle Red Bull</div>
                                <div class="text-xs text-accent-purple animate-pulse-slow">Still We Push ðŸŽï¸</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- System Status -->
            <div class="absolute top-4 right-4">
                <div class="flex items-center gap-2 bg-dark-300/50 backdrop-blur-sm rounded-full px-3 py-1.5 border border-accent-green/20">
                    <i data-lucide="activity" class="w-4 h-4 text-accent-green"></i>
                    <span class="text-xs text-gray-300">System Active</span>
                </div>
            </div>
        </div>
    </header>

    <style>
        .bg-grid-pattern {
            background-image: linear-gradient(to right, #1f2937 1px, transparent 1px),
                            linear-gradient(to bottom, #1f2937 1px, transparent 1px);
            background-size: 24px 24px;
        }

        @keyframes ping-slow {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(2); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        .animate-ping-slow {
            animation: ping-slow 3s cubic-bezier(0, 0, 0.2, 1) infinite;
        }
    </style>

    <!-- Main Chat Area -->
    <main class="flex-1 flex flex-col">
        <div class="max-w-4xl mx-auto w-full p-4 flex-1">
            <div id="chat-container" class="chat-container space-y-4 mb-4">
                <!-- Messages will be inserted here -->
            </div>

            <!-- Input Area -->
            <div class="sticky bottom-0 bg-dark-200 p-4 rounded-lg gradient-border">
                <div class="flex gap-2">
                    <input 
                        type="text" 
                        id="message-input"
                        class="flex-1 px-4 py-2 bg-dark-100 border border-dark-300/50 rounded-lg focus:outline-none focus:ring-2 focus:ring-accent-blue/50 text-gray-100"
                        placeholder="Ask me anything..."
                    >
                    <button 
                        id="send-button"
                        class="px-4 py-2 bg-gradient-to-r from-accent-blue to-accent-purple text-white rounded-lg hover:opacity-90 disabled:opacity-50 flex items-center gap-2 transition-all duration-300 cursor-pointer"
                    >
                        <span>Send</span>
                        <i data-lucide="send" class="w-4 h-4"></i>
                    </button>
                </div>
            </div>
        </div>
    </main>

    <!-- Enhanced Footer -->
    <footer class="relative bg-dark-200/95 border-t border-dark-300 mt-20 overflow-hidden backdrop-blur-sm">
        <!-- Animated Background -->
        <div class="absolute inset-0 opacity-5">
            <div class="absolute top-0 -left-4 w-48 h-48 bg-accent-blue rounded-full mix-blend-multiply filter blur-xl animate-blob"></div>
            <div class="absolute top-0 -right-4 w-48 h-48 bg-accent-purple rounded-full mix-blend-multiply filter blur-xl animate-blob animation-delay-2000"></div>
            <div class="absolute -bottom-8 left-20 w-48 h-48 bg-accent-green rounded-full mix-blend-multiply filter blur-xl animate-blob animation-delay-4000"></div>
        </div>

        <div class="max-w-7xl mx-auto">
            <!-- Upper Footer -->
            <div class="grid grid-cols-1 md:grid-cols-3 gap-8 px-6 py-8 border-b border-dark-300">
                <!-- Project Info -->
                <div class="space-y-4">
                    <div class="relative flex items-center gap-3 group">
                        <h3 class="text-xl font-bold text-gradient bg-gradient-to-r from-accent-blue via-accent-purple to-accent-green">
                            FP-GPT
                        </h3>
                        <div class="flex gap-1 animate-float">
                            <span class="animate-pulse-slow w-1 h-1 rounded-full bg-accent-blue"></span>
                            <span class="animate-pulse-slow delay-100 w-1 h-1 rounded-full bg-accent-purple"></span>
                            <span class="animate-pulse-slow delay-200 w-1 h-1 rounded-full bg-accent-green"></span>
                        </div>
                    </div>
                    <!-- Project Stats -->
                    <div class="grid grid-cols-2 gap-2">
                        <div class="bg-dark-300/30 rounded-lg p-3 border border-dark-400 hover:border-accent-blue/20 transition-all duration-300">
                            <div class="text-sm font-medium text-accent-blue mb-1">Knowledge Sources</div>
                            <div class="text-2xl font-bold text-gray-300">20+</div>
                        </div>
                        <div class="bg-dark-300/30 rounded-lg p-3 border border-dark-400 hover:border-accent-purple/20 transition-all duration-300">
                            <div class="text-sm font-medium text-accent-purple mb-1">Endpoints</div>
                            <div class="text-2xl font-bold text-gray-300">50+</div>
                        </div>
                    </div>
                    <div class="relative group">
                        <div class="absolute -inset-0.5 bg-gradient-to-r from-accent-blue via-accent-purple to-accent-green opacity-20 group-hover:opacity-100 transition-all duration-500 rounded-lg blur"></div>
                        <div class="relative p-3 bg-dark-300/50 backdrop-blur-sm rounded-lg border border-dark-400">
                            <p class="text-sm text-gray-300 leading-relaxed">
                                An advanced AI knowledge assistant powered by cutting-edge technology and real-time data integration.
                            </p>
                        </div>
                    </div>
                    <!-- Project Features -->
                    <div class="space-y-2">
                        <div class="flex items-center gap-2 text-sm text-gray-400">
                            <i data-lucide="check-circle" class="w-4 h-4 text-accent-green"></i>
                            <span>Real-time Data Integration</span>
                        </div>
                        <div class="flex items-center gap-2 text-sm text-gray-400">
                            <i data-lucide="check-circle" class="w-4 h-4 text-accent-blue"></i>
                            <span>Advanced AI Processing</span>
                        </div>
                        <div class="flex items-center gap-2 text-sm text-gray-400">
                            <i data-lucide="check-circle" class="w-4 h-4 text-accent-purple"></i>
                            <span>Multi-source Knowledge</span>
                        </div>
                    </div>
                    <div class="flex items-center space-x-3">
                        <span class="bg-gradient-to-r from-accent-blue/10 to-accent-purple/10 text-accent-blue text-xs px-2 py-1 rounded-full border border-accent-blue/20">
                            v0.3 tendi
                        </span>
                        <span class="bg-gradient-to-r from-accent-green/10 to-accent-blue/10 text-accent-green text-xs px-2 py-1 rounded-full border border-accent-green/20">
                            35% Complete
                        </span>
                    </div>
                </div>

                <!-- Quick Links -->
                <div class="space-y-4">
                    <h3 class="text-lg font-semibold text-gradient bg-gradient-to-r from-accent-green to-accent-blue">
                        Quick Links
                    </h3>
                    <div class="grid grid-cols-1 sm:grid-cols-2 gap-2">
                        <a href="roadmap.html" 
                           class="group relative flex items-center gap-2 p-2 bg-dark-300/30 rounded-lg border border-dark-400 hover:border-accent-green/30 transition-all duration-300">
                            <div class="p-2 rounded-lg bg-accent-green/10 group-hover:bg-accent-green/20 transition-colors">
                                <i data-lucide="map" class="w-4 h-4 text-accent-green"></i>
                            </div>
                            <div>
                                <span class="text-sm font-medium text-gray-300 group-hover:text-accent-green transition-colors">Roadmap</span>
                                <p class="text-xs text-gray-500">View our vision & goals</p>
                            </div>
                        </a>
                        
                        <a href="https://github.com/dronpancholi/fp-gpt" target="_blank"
                           class="group relative flex items-center gap-2 p-2 bg-dark-300/30 rounded-lg border border-dark-400 hover:border-accent-blue/30 transition-all duration-300">
                            <div class="p-2 rounded-lg bg-accent-blue/10 group-hover:bg-accent-blue/20 transition-colors">
                                <i data-lucide="github" class="w-4 h-4 text-accent-blue"></i>
                            </div>
                            <div>
                                <span class="text-sm font-medium text-gray-300 group-hover:text-accent-blue transition-colors">GitHub</span>
                                <p class="text-xs text-gray-500">Browse the code</p>
                            </div>
                        </a>
                        
                        <a href="https://twitter.com/dronpancholi" target="_blank"
                           class="group relative flex items-center gap-2 p-2 bg-dark-300/30 rounded-lg border border-dark-400 hover:border-accent-purple/30 transition-all duration-300">
                            <div class="p-2 rounded-lg bg-accent-purple/10 group-hover:bg-accent-purple/20 transition-colors">
                                <i data-lucide="twitter" class="w-4 h-4 text-accent-purple"></i>
                            </div>
                            <div>
                                <span class="text-sm font-medium text-gray-300 group-hover:text-accent-purple transition-colors">Twitter</span>
                                <p class="text-xs text-gray-500">Latest updates</p>
                            </div>
                        </a>

                        <a href="https://instagram.com/thefpgpt" target="_blank"
                           class="group relative flex items-center gap-2 p-2 bg-dark-300/30 rounded-lg border border-dark-400 hover:border-accent-green/30 transition-all duration-300">
                            <div class="p-2 rounded-lg bg-accent-green/10 group-hover:bg-accent-green/20 transition-colors">
                                <i data-lucide="instagram" class="w-4 h-4 text-accent-green"></i>
                            </div>
                            <div>
                                <span class="text-sm font-medium text-gray-300 group-hover:text-accent-green transition-colors">Instagram</span>
                                <p class="text-xs text-gray-500">Behind the scenes</p>
                            </div>
                        </a>

                        <a href="https://threads.net/@dronpancholi" target="_blank"
                           class="group relative flex items-center gap-2 p-2 bg-dark-300/30 rounded-lg border border-dark-400 hover:border-accent-blue/30 transition-all duration-300">
                            <div class="p-2 rounded-lg bg-accent-blue/10 group-hover:bg-accent-blue/20 transition-colors">
                                <i data-lucide="at-sign" class="w-4 h-4 text-accent-blue"></i>
                            </div>
                            <div>
                                <span class="text-sm font-medium text-gray-300 group-hover:text-accent-blue transition-colors">Threads</span>
                                <p class="text-xs text-gray-500">Join the conversation</p>
                            </div>
                        </a>

                        <a href="https://huggingface.co/dronpancholi" target="_blank"
                           class="group relative flex items-center gap-2 p-2 bg-dark-300/30 rounded-lg border border-dark-400 hover:border-accent-purple/30 transition-all duration-300">
                            <div class="p-2 rounded-lg bg-accent-purple/10 group-hover:bg-accent-purple/20 transition-colors">
                                <i data-lucide="box" class="w-4 h-4 text-accent-purple"></i>
                            </div>
                            <div>
                                <span class="text-sm font-medium text-gray-300 group-hover:text-accent-purple transition-colors">HuggingFace</span>
                                <p class="text-xs text-gray-500">AI models & datasets</p>
                            </div>
                        </a>

                        <button onclick="showPrivacyPolicy()" type="button"
                                class="group relative flex items-center gap-2 p-2 bg-dark-300/30 rounded-lg border border-dark-400 hover:border-accent-purple/30 transition-all duration-300">
                            <div class="p-2 rounded-lg bg-accent-purple/10 group-hover:bg-accent-purple/20 transition-colors">
                                <i data-lucide="shield" class="w-4 h-4 text-accent-purple"></i>
                            </div>
                            <div class="text-left">
                                <span class="text-sm font-medium text-gray-300 group-hover:text-accent-purple transition-colors">Privacy</span>
                                <p class="text-xs text-gray-500">Our privacy policy</p>
                            </div>
                        </button>
                          
                        <button onclick="showTerms()" type="button"
                                class="group relative flex items-center gap-2 p-2 bg-dark-300/30 rounded-lg border border-dark-400 hover:border-accent-blue/30 transition-all duration-300">
                            <div class="p-2 rounded-lg bg-accent-blue/10 group-hover:bg-accent-blue/20 transition-colors">
                                <i data-lucide="file-text" class="w-4 h-4 text-accent-blue"></i>
                            </div>
                            <div class="text-left">
                                <span class="text-sm font-medium text-gray-300 group-hover:text-accent-blue transition-colors">Terms</span>
                                <p class="text-xs text-gray-500">Terms of service</p>
                            </div>
                        </button>
                    </div>
                </div>

                <!-- Contact -->
                <div class="space-y-4">
                    <h3 class="text-lg font-semibold text-gradient bg-gradient-to-r from-accent-blue to-accent-purple">
                        Connect
                    </h3>
                    <div class="space-y-3">
                        <!-- Support Email -->
                        <a href="mailto:thefpgpt@gmail.com" 
                           class="group flex items-center gap-2 p-2 bg-dark-300/30 rounded-lg border border-dark-400 hover:border-accent-green/30 transition-all duration-300">
                            <div class="p-2 rounded-lg bg-accent-green/10 group-hover:bg-accent-green/20 transition-colors">
                                <i data-lucide="mail" class="w-4 h-4 text-accent-green"></i>
                            </div>
                            <div>
                                <span class="text-sm font-medium text-gray-300 group-hover:text-accent-green transition-colors">FP-GPT Support</span>
                                <p class="text-xs text-gray-500">thefpgpt@gmail.com</p>
                            </div>
                        </a>
                        
                        <!-- Developer Email -->
                        <a href="mailto:dronpancholi@gmail.com" 
                           class="group flex items-center gap-2 p-2 bg-dark-300/30 rounded-lg border border-dark-400 hover:border-accent-purple/30 transition-all duration-300">
                            <div class="p-2 rounded-lg bg-accent-purple/10 group-hover:bg-accent-purple/20 transition-colors">
                                <i data-lucide="mail" class="w-4 h-4 text-accent-purple"></i>
                            </div>
                            <div>
                                <span class="text-sm font-medium text-gray-300 group-hover:text-accent-purple transition-colors">Developer Contact</span>
                                <p class="text-xs text-gray-500">dronpancholi@gmail.com</p>
                            </div>
                        </a>
                        
                        <!-- Phone -->
                        <a href="tel:+918780855565" 
                           class="group flex items-center gap-2 p-2 bg-dark-300/30 rounded-lg border border-dark-400 hover:border-accent-blue/30 transition-all duration-300">
                            <div class="p-2 rounded-lg bg-accent-blue/10 group-hover:bg-accent-blue/20 transition-colors">
                                <i data-lucide="phone" class="w-4 h-4 text-accent-blue"></i>
                            </div>
                            <div>
                                <span class="text-sm font-medium text-gray-300 group-hover:text-accent-blue transition-colors">Phone</span>
                                <p class="text-xs text-gray-500">+91-8780855565</p>
                            </div>
                        </a>

                        <!-- System Status -->
                        <div class="flex items-center gap-2 text-sm text-gray-400 mt-4 bg-dark-300/30 p-2 rounded-lg border border-dark-400">
                            <i data-lucide="check-circle" class="w-4 h-4 text-accent-green"></i>
                            <span>All Systems Operational</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Lower Footer -->
            <div class="relative px-4 py-4 backdrop-blur-sm">
                <div class="flex flex-col md:flex-row justify-between items-center gap-4 text-sm">
                    <div class="flex items-center space-x-2">
                        <span class="text-gradient bg-gradient-to-r from-accent-blue via-accent-purple to-accent-green font-medium">
                            Â© 2025 FP-GPT
                        </span>
                        <span class="hidden md:inline text-dark-400">|</span>
                        <span>Created with</span>
                        <span class="animate-pulse-slow text-accent-blue">ðŸ’™</span>
                        <span>by</span>
                        <a href="https://github.com/dronpancholi" target="_blank" 
                           class="text-accent-blue hover:text-accent-purple transition-colors">
                             Dron Pancholi
                        </a>
                    </div>
                    <div class="flex items-center gap-4">
                        <button onclick="scrollToTop()" 
                                class="group flex items-center gap-2 px-3 py-1.5 rounded-full bg-dark-300/50 hover:bg-dark-300 transition-all duration-300">
                            <span class="text-sm text-gray-400 group-hover:text-accent-blue transition-colors">Back to top</span>
                            <i data-lucide="chevron-up" class="w-4 h-4 text-gray-400 group-hover:text-accent-blue transition-colors"></i>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </footer>

    <script>
        // Initialize Lucide icons
        lucide.createIcons();

        // Add these arrays before the KnowledgeAggregator class
        const apiNames = [
            'Wikipedia', 'DuckDuckGo', 'Reddit', 'Wikidata', 
            'arXiv', 'Unpaywall', 'Crossref', 'CORE', 
            'OpenCitations', 'PublicAPIs', 'GitHub', 'StackExchange',
            'RapidAPI', 'Postman', 'DBpedia', 'OpenLibrary',
            'Gutenberg', 'GlobalData', 'InfoAggregator'
        ];

        const apiTypes = [
            'encyclopedia', 'web', 'social', 'structured',
            'academic', 'academic', 'academic', 'academic',
            'academic', 'technical', 'code', 'technical',
            'technical', 'technical', 'structured', 'books', 'books',
            'data', 'news'
        ];

        // KnowledgeAggregator implementation
        class KnowledgeAggregator {
            static async getKnowledge(query) {
                try {
                    const results = await Promise.allSettled([
                        WikipediaService.search(query),
                        DuckDuckGoService.search(query),
                        RedditService.search(query),
                        WikidataService.search(query),
                        ArXivService.search(query),
                        UnpaywallService.search(query),
                        CrossrefService.search(query),
                        CoreService.search(query),
                        OpenCitationsService.search(query),
                        PublicApisService.search(query),
                        GitHubService.search(query),
                        StackExchangeService.search(query),
                        RapidApiService.search(query),
                        PostmanService.search(query),
                        DBpediaService.search(query),
                        OpenLibraryService.search(query),
                        GutenbergService.search(query),
                        GlobalDataService.search(query),
                        InfoAggregatorService.search(query)
                    ]);

                    const sources = new Map();
                    const apiConfig = this.API_CONFIG;
                    const apiNames = Object.keys(apiConfig);

                    results.forEach((result, index) => {
                        if (result.status === 'fulfilled' && result.value) {
                            const apiName = apiNames[index];
                            sources.set(apiNames[index], {
                                type: apiConfig[apiName].type,
                                content: result.value,
                                score: this.calculateRelevanceScore(result.value, query)
                            });
                        }
                    });

                    if (sources.size === 0) {
                        return "I couldn't find any relevant information about that.";
                    }

                    return this.formatResponses(sources, query);
                } catch (error) {
                    console.error('Knowledge aggregation failed:', error);
                    return "I'm having trouble accessing my knowledge sources right now.";
                }
            }

            static calculateRelevanceScore(content, query) {
                if (!content) return 0;
                
                // Basic relevance scoring
                const queryTerms = query.toLowerCase().split(' ');
                const contentLower = content.toLowerCase();
                
                let score = 0;
                // Term frequency
                queryTerms.forEach(term => {
                    const count = (contentLower.match(new RegExp(term, 'g')) || []).length;
                    score += count;
                });
                
                // Length penalty (prefer concise responses)
                score = score / Math.log(content.length);
                
                // Bonus for academic and structured content
                if (content.includes('doi.org') || content.includes('arxiv.org')) score *= 1.2;
                if (content.includes('Abstract') || content.includes('Introduction')) score *= 1.1;
                
                return score;
            }

            static formatResponses(sources, query) {
                // Sort sources by relevance score
                const sortedSources = Array.from(sources.entries())
                    .sort((a, b) => b[1].score - a[1].score);

                // Get top 2 most relevant responses
                const topResponses = sortedSources.slice(0, 2);
                const remainingSources = sortedSources.slice(2);

                // Create main container
                const container = document.createElement('div');
                container.className = 'responses-container';

                // Create responses box
                const responsesBox = document.createElement('div');
                responsesBox.className = 'responses-box';

                // Add top responses
                topResponses.forEach((source, index) => {
                    const responseDiv = document.createElement('div');
                    responseDiv.className = 'response-item';
                    responseDiv.innerHTML = `
                        <div class="response-header">Response ${index + 1}</div>
                        <div class="response-content">${source[1].content}</div>
                    `;
                    responsesBox.appendChild(responseDiv);
                });

                container.appendChild(responsesBox);

                // Add view more option if there are additional sources
                if (remainingSources.length > 0) {
                    const hiddenData = document.createElement('div');
                    hiddenData.style.display = 'none';
                    hiddenData.id = `sources-${Date.now()}`;
                    hiddenData.dataset.sources = JSON.stringify(remainingSources);
                    container.appendChild(hiddenData);

                    // Add view all button
                    const viewAllButton = document.createElement('button');
                    viewAllButton.className = 'view-all-btn';
                    viewAllButton.innerHTML = `
                        <span>View ${remainingSources.length} More Sources</span>
                        <i data-lucide="chevron-down" class="w-4 h-4"></i>
                    `;
                    viewAllButton.onclick = () => this.showAllSources(hiddenData.id);
                    container.appendChild(viewAllButton);
                    
                    // Refresh Lucide icons
                    lucide.createIcons();
                }

                return container;
            }

            static showAllSources(dataId) {
                const hiddenData = document.getElementById(dataId);
                if (!hiddenData) return;

                const sources = JSON.parse(hiddenData.dataset.sources);
                // Create modal for additional sources
                const modal = document.createElement('div');
                modal.className = 'fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4';
                
                let sourcesContent = sources.map((source, index) => `
                    <div class="response-item mb-4">
                        <div class="response-header bg-dark-400 p-2 rounded-t-lg">
                            Response ${index + 3}
                        </div>
                        <div class="response-content bg-dark-300 p-4 rounded-b-lg">
                            ${source[1].content}
                        </div>
                    </div>
                `).join('');

                modal.innerHTML = `
                    <div class="bg-dark-200 rounded-lg max-w-4xl w-full max-h-[80vh] overflow-y-auto p-6 relative">
                        <button onclick="this.closest('.fixed').remove()" 
                                class="absolute top-4 right-4 text-gray-400 hover:text-white">
                            <i data-lucide="x" class="w-5 h-5"></i>
                        </button>
                        <h2 class="text-2xl font-bold text-accent-blue mb-6">Additional Sources</h2>
                        <div class="space-y-4">
                            ${sourcesContent}
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                lucide.createIcons();

                // Remove the button and hidden data
                const button = document.querySelector('.view-all-btn');
                if (button) button.remove();
                hiddenData.remove();
            }
        }

        // Chat functionality
        class Chat {
            constructor() {
                this.chatContainer = document.querySelector('.chat-container');
                this.messageInput = document.querySelector('#message-input');
                this.sendButton = document.querySelector('#send-button');
                
                this.setupEventListeners();
            }

            setupEventListeners() {
                this.sendButton.addEventListener('click', () => this.handleSend());
                this.messageInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.handleSend();
                    }
                });
            }

            async handleSend() {
                const message = this.messageInput.value.trim();
                if (!message) return;

                // Clear input
                this.messageInput.value = '';

                // Add user message
                this.addMessage(message, 'user');

                // Show typing indicator
                this.showTypingIndicator();

                try {
                    // Get response from KnowledgeAggregator
                    const response = await this.getKnowledge(message);
                    
                    // Remove typing indicator and add response
                    this.removeTypingIndicator();
                    this.addMessage(response, 'assistant');
                } catch (error) {
                    console.error('Failed to get response:', error);
                    this.removeTypingIndicator();
                    this.addMessage("I'm sorry, I encountered an error while processing your request.", 'assistant');
                }
            }

            async getKnowledge(query) {
                try {
                    this.updateTypingIndicator('Searching knowledge sources...');
                    const response = await KnowledgeAggregator.getKnowledge(query);
                    
                    if (!response) {
                        return "I couldn't find specific information about that. Please try rephrasing your question.";
                    }

                    return response;
                } catch (error) {
                    console.error('Knowledge aggregation failed:', error);
                    return "I apologize, but I'm having trouble accessing my knowledge sources. Please try again in a moment.";
                }
            }

            updateTypingIndicator(message) {
                const indicator = document.getElementById('typing-indicator');
                if (indicator) {
                    const messageSpan = indicator.querySelector('.typing-message');
                    if (messageSpan) {
                        messageSpan.textContent = message;
                    } else {
                        const span = document.createElement('span');
                        span.className = 'typing-message text-sm text-gray-400 ml-2';
                        span.textContent = message;
                        indicator.appendChild(span);
                    }
                }
            }

            showTypingIndicator() {
                const indicator = document.createElement('div');
                indicator.className = 'typing-indicator flex items-center';
                indicator.id = 'typing-indicator';
                indicator.innerHTML = `
                    <div class="flex space-x-1">
                        <span></span>
                        <span></span>
                        <span></span>
                    </div>
                    <span class="typing-message text-sm text-gray-400 ml-2">Thinking...</span>
                `;
                this.chatContainer.appendChild(indicator);
                this.scrollToBottom();
            }

            // Add CSS for better typing indicator
            static addStyles() {
                const style = document.createElement('style');
                style.textContent = `
                    .typing-indicator {
                        background-color: #1e2235;
                        padding: 12px 16px;
                        border-radius: 12px;
                        margin: 8px 0;
                        display: flex;
                        align-items: center;
                    }

                    .typing-indicator span {
                        display: inline-block;
                        width: 8px;
                        height: 8px;
                        background-color: #60a5fa;
                        border-radius: 50%;
                        margin: 0 2px;
                        animation: bounce 1.4s infinite ease-in-out;
                    }

                    .typing-indicator span:nth-child(1) { animation-delay: 0s; }
                    .typing-indicator span:nth-child(2) { animation-delay: 0.2s; }
                    .typing-indicator span:nth-child(3) { animation-delay: 0.4s; }

                    @keyframes bounce {
                        0%, 80%, 100% { transform: translateY(0); }
                        40% { transform: translateY(-8px); }
                    }
                `;
                document.head.appendChild(style);
            }

            addMessage(content, type) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${type}-message`;
                
                // Check if content is an HTML element
                if (content instanceof HTMLElement) {
                    messageDiv.appendChild(content);
                } else {
                    messageDiv.textContent = content;
                }
                
                this.chatContainer.appendChild(messageDiv);
                this.scrollToBottom();
            }

            removeTypingIndicator() {
                const indicator = document.getElementById('typing-indicator');
                if (indicator) {
                    indicator.remove();
                }
            }

            scrollToBottom() {
                this.chatContainer.scrollTop = this.chatContainer.scrollHeight;
            }
        }

        // Initialize chat and styles when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            Chat.addStyles();
            const chat = new Chat();
            
            // Add welcome message
            chat.addMessage(`ðŸ‘‹ Welcome to FP-GPT!

I'm Dron Pancholi, the creator of this AI knowledge assistant. FP-GPT is designed to provide comprehensive answers by aggregating information from multiple reliable sources in real-time. ALSO CHECK OUT V0.1 IS LIVE!!!

Feel free to:
â€¢ Ask any question
â€¢ Explore complex topics
â€¢ Get real-time information
â€¢ Access multiple knowledge sources including academic papers from arXiv

Try asking something like:
"What are the latest developments in quantum computing?"
"Show me recent research papers on machine learning"
or
"Explain the impact of AI on healthcare"

Let me know if you need any help! ðŸš€`, 'assistant');
            
            // Refresh Lucide icons after any dynamic content changes
            lucide.createIcons();
        });

        // Smooth scroll to top
        function scrollToTop() {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        }

        // Privacy Policy Modal
        function showPrivacyPolicy() {
            event.preventDefault();
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-50 p-4';
            modal.innerHTML = `
                <div class="bg-dark-200/95 backdrop-blur-sm rounded-lg max-w-2xl w-full max-h-[80vh] overflow-y-auto relative">
                    <div class="sticky top-0 bg-dark-200/95 backdrop-blur-sm p-6 border-b border-dark-400 flex items-center justify-between">
                        <h2 class="text-2xl font-bold text-gradient bg-gradient-to-r from-accent-blue to-accent-purple">Privacy Policy</h2>
                        <button onclick="this.closest('.fixed').remove()" 
                                class="p-2 hover:bg-dark-300 rounded-lg transition-colors">
                            <i data-lucide="x" class="w-5 h-5 text-gray-400"></i>
                        </button>
                    </div>
                    <div class="p-6 prose prose-invert prose-sm">
                        <p class="text-gray-400">Last updated: January 2025</p>
                        <h3 class="text-lg font-semibold text-white mt-6">Information We Collect</h3>
                        <ul class="text-gray-300 list-disc pl-5 space-y-2">
                            <li>Query content and search history</li>
                            <li>Usage patterns and interaction data</li>
                            <li>Technical information (browser type, device info)</li>
                            <li>Performance metrics and error logs</li>
                        </ul>

                        <h3 class="text-lg font-semibold text-white mt-6">How We Use Your Information</h3>
                        <ul class="text-gray-300 list-disc pl-5 space-y-2">
                            <li>Improve search results and relevance</li>
                            <li>Enhance user experience and interface</li>
                            <li>Debug and optimize performance</li>
                            <li>Develop new features and capabilities</li>
                        </ul>

                        <h3 class="text-lg font-semibold text-white mt-6">Data Security</h3>
                        <p class="text-gray-300">
                            We implement industry-standard security measures to protect your data:
                        </p>
                        <ul class="text-gray-300 list-disc pl-5 space-y-2">
                            <li>End-to-end encryption for all communications</li>
                            <li>Regular security audits and updates</li>
                            <li>Secure data storage and handling</li>
                            <li>Limited employee access to user data</li>
                        </ul>

                        <h3 class="text-lg font-semibold text-white mt-6">Your Rights</h3>
                        <p class="text-gray-300">
                            You have the right to:
                        </p>
                        <ul class="text-gray-300 list-disc pl-5 space-y-2">
                            <li>Access your personal data</li>
                            <li>Request data deletion</li>
                            <li>Opt-out of data collection</li>
                            <li>Export your data</li>
                        </ul>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            lucide.createIcons();
        }

        // Terms & Conditions Modal
        function showTerms() {
            event.preventDefault();
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-50 p-4';
            modal.innerHTML = `
                <div class="bg-dark-200/95 backdrop-blur-sm rounded-lg max-w-2xl w-full max-h-[80vh] overflow-y-auto relative">
                    <div class="sticky top-0 bg-dark-200/95 backdrop-blur-sm p-6 border-b border-dark-400 flex items-center justify-between">
                        <h2 class="text-2xl font-bold text-gradient bg-gradient-to-r from-accent-blue to-accent-purple">Terms & Conditions</h2>
                        <button onclick="this.closest('.fixed').remove()" 
                                class="p-2 hover:bg-dark-300 rounded-lg transition-colors">
                            <i data-lucide="x" class="w-5 h-5 text-gray-400"></i>
                        </button>
                    </div>
                    <div class="p-6 prose prose-invert prose-sm">
                        <p class="text-gray-400">Last updated: January 2025</p>
                        <h3 class="text-lg font-semibold text-white mt-6">1. Acceptance of Terms</h3>
                        <p class="text-gray-300">
                            By accessing or using FP-GPT, you agree to be bound by these terms and conditions, all applicable laws and regulations, and agree that you are responsible for compliance with any applicable local laws.
                        </p>
                        <h3 class="text-lg font-semibold text-white mt-6">2. Use License</h3>
                        <ul class="text-gray-300 list-disc pl-5 space-y-2">
                            <li>Personal, non-commercial use only</li>
                            <li>No reproduction without permission</li>
                            <li>No modification or derivative works</li>
                            <li>No unauthorized distribution</li>
                        </ul>

                        <h3 class="text-lg font-semibold text-white mt-6">3. Disclaimer</h3>
                        <p class="text-gray-300">
                            The materials on FP-GPT are provided on an 'as is' basis. We make no warranties, expressed or implied, and hereby disclaim and negate all other warranties including, without limitation, implied warranties or conditions of merchantability, fitness for a particular purpose, or non-infringement of intellectual property or other violation of rights.
                        </p>
                        <h3 class="text-lg font-semibold text-white mt-6">4. Limitations</h3>
                        <ul class="text-gray-300 list-disc pl-5 space-y-2">
                            <li>No guarantee of continuous service</li>
                            <li>Right to modify or discontinue service</li>
                            <li>No liability for data loss or damage</li>
                            <li>Usage limits may apply</li>
                        </ul>

                        <h3 class="text-lg font-semibold text-white mt-6">5. Governing Law</h3>
                        <p class="text-gray-300">
                            These terms and conditions are governed by and construed in accordance with the laws, and you irrevocably submit to the exclusive jurisdiction of the courts in that location.
                        </p>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            lucide.createIcons();
        }
    </script>
</body>
</html> 
